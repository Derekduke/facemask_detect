// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_types_generated.h"

namespace mindspore {
namespace schema {

struct Abs;
struct AbsBuilder;

struct Activation;
struct ActivationBuilder;

struct ActivationGrad;
struct ActivationGradBuilder;

struct Adam;
struct AdamBuilder;

struct AddFusion;
struct AddFusionBuilder;

struct AdderFusion;
struct AdderFusionBuilder;

struct AddGrad;
struct AddGradBuilder;

struct AddN;
struct AddNBuilder;

struct All;
struct AllBuilder;

struct ApplyMomentum;
struct ApplyMomentumBuilder;

struct ArgMaxFusion;
struct ArgMaxFusionBuilder;

struct ArgMinFusion;
struct ArgMinFusionBuilder;

struct Assert;
struct AssertBuilder;

struct Assign;
struct AssignBuilder;

struct AssignAdd;
struct AssignAddBuilder;

struct AudioSpectrogram;
struct AudioSpectrogramBuilder;

struct AvgPoolFusion;
struct AvgPoolFusionBuilder;

struct AvgPoolGrad;
struct AvgPoolGradBuilder;

struct BatchNorm;
struct BatchNormBuilder;

struct BatchNormGrad;
struct BatchNormGradBuilder;

struct BatchToSpace;
struct BatchToSpaceBuilder;

struct BatchToSpaceND;
struct BatchToSpaceNDBuilder;

struct BiasAdd;
struct BiasAddBuilder;

struct BinaryCrossEntropy;
struct BinaryCrossEntropyBuilder;

struct BinaryCrossEntropyGrad;
struct BinaryCrossEntropyGradBuilder;

struct BiasAddGrad;
struct BiasAddGradBuilder;

struct BroadcastTo;
struct BroadcastToBuilder;

struct Cast;
struct CastBuilder;

struct Ceil;
struct CeilBuilder;

struct Clip;
struct ClipBuilder;

struct Concat;
struct ConcatBuilder;

struct Attention;
struct AttentionBuilder;

struct Conv2DBackpropFilterFusion;
struct Conv2DBackpropFilterFusionBuilder;

struct Conv2DBackpropInputFusion;
struct Conv2DBackpropInputFusionBuilder;

struct Conv2DFusion;
struct Conv2DFusionBuilder;

struct Conv2dTransposeFusion;
struct Conv2dTransposeFusionBuilder;

struct Cos;
struct CosBuilder;

struct ConstantOfShape;
struct ConstantOfShapeBuilder;

struct Crop;
struct CropBuilder;

struct CustomExtractFeatures;
struct CustomExtractFeaturesBuilder;

struct CustomNormalize;
struct CustomNormalizeBuilder;

struct CustomPredict;
struct CustomPredictBuilder;

struct DeConv2DGradFilter;
struct DeConv2DGradFilterBuilder;

struct Depend;
struct DependBuilder;

struct DepthToSpace;
struct DepthToSpaceBuilder;

struct DetectionPostProcess;
struct DetectionPostProcessBuilder;

struct DivFusion;
struct DivFusionBuilder;

struct DivGrad;
struct DivGradBuilder;

struct Dropout;
struct DropoutBuilder;

struct DropoutGrad;
struct DropoutGradBuilder;

struct Elu;
struct EluBuilder;

struct Eltwise;
struct EltwiseBuilder;

struct Equal;
struct EqualBuilder;

struct EmbeddingLookupFusion;
struct EmbeddingLookupFusionBuilder;

struct ExpFusion;
struct ExpFusionBuilder;

struct ExpandDims;
struct ExpandDimsBuilder;

struct FakeQuantWithMinMaxVars;
struct FakeQuantWithMinMaxVarsBuilder;

struct FakeQuantWithMinMaxVarsPerChannel;
struct FakeQuantWithMinMaxVarsPerChannelBuilder;

struct FftReal;
struct FftRealBuilder;

struct FftImag;
struct FftImagBuilder;

struct Flatten;
struct FlattenBuilder;

struct FlattenGrad;
struct FlattenGradBuilder;

struct Floor;
struct FloorBuilder;

struct FloorDiv;
struct FloorDivBuilder;

struct FloorMod;
struct FloorModBuilder;

struct Fill;
struct FillBuilder;

struct FullConnection;
struct FullConnectionBuilder;

struct FusedBatchNorm;
struct FusedBatchNormBuilder;

struct Gather;
struct GatherBuilder;

struct GatherNd;
struct GatherNdBuilder;

struct Greater;
struct GreaterBuilder;

struct GreaterEqual;
struct GreaterEqualBuilder;

struct HashtableLookup;
struct HashtableLookupBuilder;

struct InstanceNorm;
struct InstanceNormBuilder;

struct LayerNormFusion;
struct LayerNormFusionBuilder;

struct LeakyRelu;
struct LeakyReluBuilder;

struct Less;
struct LessBuilder;

struct LessEqual;
struct LessEqualBuilder;

struct Log;
struct LogBuilder;

struct LogGrad;
struct LogGradBuilder;

struct LogicalAnd;
struct LogicalAndBuilder;

struct LogicalNot;
struct LogicalNotBuilder;

struct LogicalOr;
struct LogicalOrBuilder;

struct LpNormalization;
struct LpNormalizationBuilder;

struct LRN;
struct LRNBuilder;

struct LshProjection;
struct LshProjectionBuilder;

struct LSTM;
struct LSTMBuilder;

struct LSTMGrad;
struct LSTMGradBuilder;

struct L2NormalizeFusion;
struct L2NormalizeFusionBuilder;

struct MatMulFusion;
struct MatMulFusionBuilder;

struct Maximum;
struct MaximumBuilder;

struct MaximumGrad;
struct MaximumGradBuilder;

struct MaxPoolFusion;
struct MaxPoolFusionBuilder;

struct MaxPoolGrad;
struct MaxPoolGradBuilder;

struct SwitchLayer;
struct SwitchLayerBuilder;

struct Mfcc;
struct MfccBuilder;

struct Minimum;
struct MinimumBuilder;

struct MinimumGrad;
struct MinimumGradBuilder;

struct Mod;
struct ModBuilder;

struct MulFusion;
struct MulFusionBuilder;

struct MulGrad;
struct MulGradBuilder;

struct Neg;
struct NegBuilder;

struct NegGrad;
struct NegGradBuilder;

struct NotEqual;
struct NotEqualBuilder;

struct NonMaxSuppression;
struct NonMaxSuppressionBuilder;

struct OneHot;
struct OneHotBuilder;

struct OnesLike;
struct OnesLikeBuilder;

struct PadFusion;
struct PadFusionBuilder;

struct PartialFusion;
struct PartialFusionBuilder;

struct PowerGrad;
struct PowerGradBuilder;

struct PowFusion;
struct PowFusionBuilder;

struct PriorBox;
struct PriorBoxBuilder;

struct PReLUFusion;
struct PReLUFusionBuilder;

struct Rank;
struct RankBuilder;

struct Range;
struct RangeBuilder;

struct Reciprocal;
struct ReciprocalBuilder;

struct RealDiv;
struct RealDivBuilder;

struct ReduceFusion;
struct ReduceFusionBuilder;

struct Reshape;
struct ReshapeBuilder;

struct Resize;
struct ResizeBuilder;

struct ReverseSequence;
struct ReverseSequenceBuilder;

struct ReverseV2;
struct ReverseV2Builder;

struct Rfft;
struct RfftBuilder;

struct ROIPooling;
struct ROIPoolingBuilder;

struct Round;
struct RoundBuilder;

struct Rsqrt;
struct RsqrtBuilder;

struct QuantDTypeCast;
struct QuantDTypeCastBuilder;

struct ScaleFusion;
struct ScaleFusionBuilder;

struct ScatterNd;
struct ScatterNdBuilder;

struct SGD;
struct SGDBuilder;

struct Shape;
struct ShapeBuilder;

struct SigmoidCrossEntropyWithLogits;
struct SigmoidCrossEntropyWithLogitsBuilder;

struct SigmoidCrossEntropyWithLogitsGrad;
struct SigmoidCrossEntropyWithLogitsGradBuilder;

struct Sin;
struct SinBuilder;

struct SkipGram;
struct SkipGramBuilder;

struct SliceFusion;
struct SliceFusionBuilder;

struct SmoothL1Loss;
struct SmoothL1LossBuilder;

struct SmoothL1LossGrad;
struct SmoothL1LossGradBuilder;

struct Softmax;
struct SoftmaxBuilder;

struct SoftmaxCrossEntropyWithLogits;
struct SoftmaxCrossEntropyWithLogitsBuilder;

struct SpaceToBatch;
struct SpaceToBatchBuilder;

struct SpaceToBatchND;
struct SpaceToBatchNDBuilder;

struct SpaceToDepth;
struct SpaceToDepthBuilder;

struct SparseSoftmaxCrossEntropyWithLogits;
struct SparseSoftmaxCrossEntropyWithLogitsBuilder;

struct SparseToDense;
struct SparseToDenseBuilder;

struct Split;
struct SplitBuilder;

struct Sqrt;
struct SqrtBuilder;

struct Squeeze;
struct SqueezeBuilder;

struct Square;
struct SquareBuilder;

struct SquaredDifference;
struct SquaredDifferenceBuilder;

struct Stack;
struct StackBuilder;

struct StridedSlice;
struct StridedSliceBuilder;

struct SubFusion;
struct SubFusionBuilder;

struct SubGrad;
struct SubGradBuilder;

struct Switch;
struct SwitchBuilder;

struct TensorListFromTensor;
struct TensorListFromTensorBuilder;

struct TensorListGetItem;
struct TensorListGetItemBuilder;

struct TensorListReserve;
struct TensorListReserveBuilder;

struct TensorListSetItem;
struct TensorListSetItemBuilder;

struct TensorListStack;
struct TensorListStackBuilder;

struct TileFusion;
struct TileFusionBuilder;

struct TopKFusion;
struct TopKFusionBuilder;

struct Transpose;
struct TransposeBuilder;

struct Unique;
struct UniqueBuilder;

struct UnsortedSegmentSum;
struct UnsortedSegmentSumBuilder;

struct Unsqueeze;
struct UnsqueezeBuilder;

struct Unstack;
struct UnstackBuilder;

struct Where;
struct WhereBuilder;

struct ZerosLike;
struct ZerosLikeBuilder;

struct Select;
struct SelectBuilder;

struct GRU;
struct GRUBuilder;

struct NonZero;
struct NonZeroBuilder;

struct InvertPermutation;
struct InvertPermutationBuilder;

struct Size;
struct SizeBuilder;

struct RandomStandardNormal;
struct RandomStandardNormalBuilder;

struct CropAndResize;
struct CropAndResizeBuilder;

struct Erf;
struct ErfBuilder;

struct StridedSliceGrad;
struct StridedSliceGradBuilder;

struct IsFinite;
struct IsFiniteBuilder;

struct LinSpace;
struct LinSpaceBuilder;

struct UniformReal;
struct UniformRealBuilder;

struct AbsGrad;
struct AbsGradBuilder;

struct RsqrtGrad;
struct RsqrtGradBuilder;

struct SqrtGrad;
struct SqrtGradBuilder;

struct LayerNormGrad;
struct LayerNormGradBuilder;

struct ResizeGrad;
struct ResizeGradBuilder;

struct Splice;
struct SpliceBuilder;

struct LogSoftmax;
struct LogSoftmaxBuilder;

struct Call;
struct CallBuilder;

struct CumSum;
struct CumSumBuilder;

struct Custom;
struct CustomBuilder;

struct SplitWithOverlap;
struct SplitWithOverlapBuilder;

struct GenOP;
struct GenOPBuilder;

struct RaggedRange;
struct RaggedRangeBuilder;

struct GLU;
struct GLUBuilder;

struct TensorArray;
struct TensorArrayBuilder;

struct TensorArrayRead;
struct TensorArrayReadBuilder;

struct TensorArrayWrite;
struct TensorArrayWriteBuilder;

struct Affine;
struct AffineBuilder;

struct ScatterNdUpdate;
struct ScatterNdUpdateBuilder;

struct AllGather;
struct AllGatherBuilder;

struct ReduceScatter;
struct ReduceScatterBuilder;

enum PrimitiveType : uint8_t {
  PrimitiveType_NONE = 0,
  PrimitiveType_Abs = 1,
  PrimitiveType_Activation = 2,
  PrimitiveType_ActivationGrad = 3,
  PrimitiveType_Adam = 4,
  PrimitiveType_AddFusion = 5,
  PrimitiveType_AdderFusion = 6,
  PrimitiveType_AddGrad = 7,
  PrimitiveType_AddN = 8,
  PrimitiveType_All = 9,
  PrimitiveType_ApplyMomentum = 10,
  PrimitiveType_ArgMaxFusion = 11,
  PrimitiveType_ArgMinFusion = 12,
  PrimitiveType_Assert = 13,
  PrimitiveType_Assign = 14,
  PrimitiveType_AssignAdd = 15,
  PrimitiveType_AudioSpectrogram = 16,
  PrimitiveType_AvgPoolFusion = 17,
  PrimitiveType_AvgPoolGrad = 18,
  PrimitiveType_BatchNorm = 19,
  PrimitiveType_BatchNormGrad = 20,
  PrimitiveType_BatchToSpace = 21,
  PrimitiveType_BatchToSpaceND = 22,
  PrimitiveType_BiasAdd = 23,
  PrimitiveType_BinaryCrossEntropy = 24,
  PrimitiveType_BinaryCrossEntropyGrad = 25,
  PrimitiveType_BiasAddGrad = 26,
  PrimitiveType_BroadcastTo = 27,
  PrimitiveType_Cast = 28,
  PrimitiveType_Ceil = 29,
  PrimitiveType_Clip = 30,
  PrimitiveType_Concat = 31,
  PrimitiveType_Attention = 32,
  PrimitiveType_Conv2DBackpropFilterFusion = 33,
  PrimitiveType_Conv2DBackpropInputFusion = 34,
  PrimitiveType_Conv2DFusion = 35,
  PrimitiveType_Conv2dTransposeFusion = 36,
  PrimitiveType_Cos = 37,
  PrimitiveType_ConstantOfShape = 38,
  PrimitiveType_Crop = 39,
  PrimitiveType_CustomExtractFeatures = 40,
  PrimitiveType_CustomNormalize = 41,
  PrimitiveType_CustomPredict = 42,
  PrimitiveType_DeConv2DGradFilter = 43,
  PrimitiveType_Depend = 44,
  PrimitiveType_DepthToSpace = 45,
  PrimitiveType_DetectionPostProcess = 46,
  PrimitiveType_DivFusion = 47,
  PrimitiveType_DivGrad = 48,
  PrimitiveType_Dropout = 49,
  PrimitiveType_DropoutGrad = 50,
  PrimitiveType_Elu = 51,
  PrimitiveType_Eltwise = 52,
  PrimitiveType_Equal = 53,
  PrimitiveType_EmbeddingLookupFusion = 54,
  PrimitiveType_ExpFusion = 55,
  PrimitiveType_ExpandDims = 56,
  PrimitiveType_FakeQuantWithMinMaxVars = 57,
  PrimitiveType_FakeQuantWithMinMaxVarsPerChannel = 58,
  PrimitiveType_FftReal = 59,
  PrimitiveType_FftImag = 60,
  PrimitiveType_Flatten = 61,
  PrimitiveType_FlattenGrad = 62,
  PrimitiveType_Floor = 63,
  PrimitiveType_FloorDiv = 64,
  PrimitiveType_FloorMod = 65,
  PrimitiveType_Fill = 66,
  PrimitiveType_FullConnection = 67,
  PrimitiveType_FusedBatchNorm = 68,
  PrimitiveType_Gather = 69,
  PrimitiveType_GatherNd = 70,
  PrimitiveType_Greater = 71,
  PrimitiveType_GreaterEqual = 72,
  PrimitiveType_HashtableLookup = 73,
  PrimitiveType_InstanceNorm = 74,
  PrimitiveType_LayerNormFusion = 75,
  PrimitiveType_LeakyRelu = 76,
  PrimitiveType_Less = 77,
  PrimitiveType_LessEqual = 78,
  PrimitiveType_Log = 79,
  PrimitiveType_LogGrad = 80,
  PrimitiveType_LogicalAnd = 81,
  PrimitiveType_LogicalNot = 82,
  PrimitiveType_LogicalOr = 83,
  PrimitiveType_LpNormalization = 84,
  PrimitiveType_LRN = 85,
  PrimitiveType_LshProjection = 86,
  PrimitiveType_LSTM = 87,
  PrimitiveType_L2NormalizeFusion = 88,
  PrimitiveType_MatMulFusion = 89,
  PrimitiveType_Maximum = 90,
  PrimitiveType_MaximumGrad = 91,
  PrimitiveType_MaxPoolFusion = 92,
  PrimitiveType_MaxPoolGrad = 93,
  PrimitiveType_SwitchLayer = 94,
  PrimitiveType_Mfcc = 95,
  PrimitiveType_Minimum = 96,
  PrimitiveType_MinimumGrad = 97,
  PrimitiveType_Mod = 98,
  PrimitiveType_MulFusion = 99,
  PrimitiveType_MulGrad = 100,
  PrimitiveType_Neg = 101,
  PrimitiveType_NegGrad = 102,
  PrimitiveType_NotEqual = 103,
  PrimitiveType_NonMaxSuppression = 104,
  PrimitiveType_OneHot = 105,
  PrimitiveType_OnesLike = 106,
  PrimitiveType_PadFusion = 107,
  PrimitiveType_PartialFusion = 108,
  PrimitiveType_PowerGrad = 109,
  PrimitiveType_PowFusion = 110,
  PrimitiveType_PriorBox = 111,
  PrimitiveType_PReLUFusion = 112,
  PrimitiveType_QuantDTypeCast = 113,
  PrimitiveType_Rank = 114,
  PrimitiveType_Range = 115,
  PrimitiveType_Reciprocal = 116,
  PrimitiveType_RealDiv = 117,
  PrimitiveType_ReduceFusion = 118,
  PrimitiveType_Reshape = 119,
  PrimitiveType_Resize = 120,
  PrimitiveType_ReverseSequence = 121,
  PrimitiveType_ReverseV2 = 122,
  PrimitiveType_Rfft = 123,
  PrimitiveType_ROIPooling = 124,
  PrimitiveType_Round = 125,
  PrimitiveType_Rsqrt = 126,
  PrimitiveType_ScaleFusion = 127,
  PrimitiveType_ScatterNd = 128,
  PrimitiveType_SGD = 129,
  PrimitiveType_Shape = 130,
  PrimitiveType_SigmoidCrossEntropyWithLogits = 131,
  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 132,
  PrimitiveType_Sin = 133,
  PrimitiveType_SkipGram = 134,
  PrimitiveType_SliceFusion = 135,
  PrimitiveType_SmoothL1Loss = 136,
  PrimitiveType_SmoothL1LossGrad = 137,
  PrimitiveType_Softmax = 138,
  PrimitiveType_SoftmaxCrossEntropyWithLogits = 139,
  PrimitiveType_SpaceToBatch = 140,
  PrimitiveType_SpaceToBatchND = 141,
  PrimitiveType_SpaceToDepth = 142,
  PrimitiveType_SparseSoftmaxCrossEntropyWithLogits = 143,
  PrimitiveType_SparseToDense = 144,
  PrimitiveType_Split = 145,
  PrimitiveType_Sqrt = 146,
  PrimitiveType_Squeeze = 147,
  PrimitiveType_Square = 148,
  PrimitiveType_SquaredDifference = 149,
  PrimitiveType_Stack = 150,
  PrimitiveType_StridedSlice = 151,
  PrimitiveType_SubFusion = 152,
  PrimitiveType_SubGrad = 153,
  PrimitiveType_Switch = 154,
  PrimitiveType_TensorListFromTensor = 155,
  PrimitiveType_TensorListGetItem = 156,
  PrimitiveType_TensorListReserve = 157,
  PrimitiveType_TensorListSetItem = 158,
  PrimitiveType_TensorListStack = 159,
  PrimitiveType_TileFusion = 160,
  PrimitiveType_TopKFusion = 161,
  PrimitiveType_Transpose = 162,
  PrimitiveType_Unique = 163,
  PrimitiveType_UnsortedSegmentSum = 164,
  PrimitiveType_Unsqueeze = 165,
  PrimitiveType_Unstack = 166,
  PrimitiveType_LSTMGrad = 167,
  PrimitiveType_Where = 168,
  PrimitiveType_ZerosLike = 169,
  PrimitiveType_Select = 170,
  PrimitiveType_ScatterNdUpdate = 171,
  PrimitiveType_GRU = 172,
  PrimitiveType_NonZero = 173,
  PrimitiveType_InvertPermutation = 174,
  PrimitiveType_Size = 175,
  PrimitiveType_RandomStandardNormal = 176,
  PrimitiveType_CropAndResize = 177,
  PrimitiveType_Erf = 178,
  PrimitiveType_StridedSliceGrad = 179,
  PrimitiveType_IsFinite = 180,
  PrimitiveType_LinSpace = 181,
  PrimitiveType_UniformReal = 182,
  PrimitiveType_AbsGrad = 183,
  PrimitiveType_RsqrtGrad = 184,
  PrimitiveType_SqrtGrad = 185,
  PrimitiveType_LayerNormGrad = 186,
  PrimitiveType_ResizeGrad = 187,
  PrimitiveType_Splice = 188,
  PrimitiveType_LogSoftmax = 189,
  PrimitiveType_Call = 190,
  PrimitiveType_Custom = 191,
  PrimitiveType_CumSum = 192,
  PrimitiveType_SplitWithOverlap = 193,
  PrimitiveType_GenOP = 194,
  PrimitiveType_RaggedRange = 195,
  PrimitiveType_GLU = 196,
  PrimitiveType_TensorArray = 197,
  PrimitiveType_TensorArrayRead = 198,
  PrimitiveType_TensorArrayWrite = 199,
  PrimitiveType_Affine = 200,
  PrimitiveType_AllGather = 201,
  PrimitiveType_ReduceScatter = 202,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_ReduceScatter
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[203] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Abs,
    PrimitiveType_Activation,
    PrimitiveType_ActivationGrad,
    PrimitiveType_Adam,
    PrimitiveType_AddFusion,
    PrimitiveType_AdderFusion,
    PrimitiveType_AddGrad,
    PrimitiveType_AddN,
    PrimitiveType_All,
    PrimitiveType_ApplyMomentum,
    PrimitiveType_ArgMaxFusion,
    PrimitiveType_ArgMinFusion,
    PrimitiveType_Assert,
    PrimitiveType_Assign,
    PrimitiveType_AssignAdd,
    PrimitiveType_AudioSpectrogram,
    PrimitiveType_AvgPoolFusion,
    PrimitiveType_AvgPoolGrad,
    PrimitiveType_BatchNorm,
    PrimitiveType_BatchNormGrad,
    PrimitiveType_BatchToSpace,
    PrimitiveType_BatchToSpaceND,
    PrimitiveType_BiasAdd,
    PrimitiveType_BinaryCrossEntropy,
    PrimitiveType_BinaryCrossEntropyGrad,
    PrimitiveType_BiasAddGrad,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Cast,
    PrimitiveType_Ceil,
    PrimitiveType_Clip,
    PrimitiveType_Concat,
    PrimitiveType_Attention,
    PrimitiveType_Conv2DBackpropFilterFusion,
    PrimitiveType_Conv2DBackpropInputFusion,
    PrimitiveType_Conv2DFusion,
    PrimitiveType_Conv2dTransposeFusion,
    PrimitiveType_Cos,
    PrimitiveType_ConstantOfShape,
    PrimitiveType_Crop,
    PrimitiveType_CustomExtractFeatures,
    PrimitiveType_CustomNormalize,
    PrimitiveType_CustomPredict,
    PrimitiveType_DeConv2DGradFilter,
    PrimitiveType_Depend,
    PrimitiveType_DepthToSpace,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_DivFusion,
    PrimitiveType_DivGrad,
    PrimitiveType_Dropout,
    PrimitiveType_DropoutGrad,
    PrimitiveType_Elu,
    PrimitiveType_Eltwise,
    PrimitiveType_Equal,
    PrimitiveType_EmbeddingLookupFusion,
    PrimitiveType_ExpFusion,
    PrimitiveType_ExpandDims,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_FakeQuantWithMinMaxVarsPerChannel,
    PrimitiveType_FftReal,
    PrimitiveType_FftImag,
    PrimitiveType_Flatten,
    PrimitiveType_FlattenGrad,
    PrimitiveType_Floor,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_Fill,
    PrimitiveType_FullConnection,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Greater,
    PrimitiveType_GreaterEqual,
    PrimitiveType_HashtableLookup,
    PrimitiveType_InstanceNorm,
    PrimitiveType_LayerNormFusion,
    PrimitiveType_LeakyRelu,
    PrimitiveType_Less,
    PrimitiveType_LessEqual,
    PrimitiveType_Log,
    PrimitiveType_LogGrad,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalNot,
    PrimitiveType_LogicalOr,
    PrimitiveType_LpNormalization,
    PrimitiveType_LRN,
    PrimitiveType_LshProjection,
    PrimitiveType_LSTM,
    PrimitiveType_L2NormalizeFusion,
    PrimitiveType_MatMulFusion,
    PrimitiveType_Maximum,
    PrimitiveType_MaximumGrad,
    PrimitiveType_MaxPoolFusion,
    PrimitiveType_MaxPoolGrad,
    PrimitiveType_SwitchLayer,
    PrimitiveType_Mfcc,
    PrimitiveType_Minimum,
    PrimitiveType_MinimumGrad,
    PrimitiveType_Mod,
    PrimitiveType_MulFusion,
    PrimitiveType_MulGrad,
    PrimitiveType_Neg,
    PrimitiveType_NegGrad,
    PrimitiveType_NotEqual,
    PrimitiveType_NonMaxSuppression,
    PrimitiveType_OneHot,
    PrimitiveType_OnesLike,
    PrimitiveType_PadFusion,
    PrimitiveType_PartialFusion,
    PrimitiveType_PowerGrad,
    PrimitiveType_PowFusion,
    PrimitiveType_PriorBox,
    PrimitiveType_PReLUFusion,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Rank,
    PrimitiveType_Range,
    PrimitiveType_Reciprocal,
    PrimitiveType_RealDiv,
    PrimitiveType_ReduceFusion,
    PrimitiveType_Reshape,
    PrimitiveType_Resize,
    PrimitiveType_ReverseSequence,
    PrimitiveType_ReverseV2,
    PrimitiveType_Rfft,
    PrimitiveType_ROIPooling,
    PrimitiveType_Round,
    PrimitiveType_Rsqrt,
    PrimitiveType_ScaleFusion,
    PrimitiveType_ScatterNd,
    PrimitiveType_SGD,
    PrimitiveType_Shape,
    PrimitiveType_SigmoidCrossEntropyWithLogits,
    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
    PrimitiveType_Sin,
    PrimitiveType_SkipGram,
    PrimitiveType_SliceFusion,
    PrimitiveType_SmoothL1Loss,
    PrimitiveType_SmoothL1LossGrad,
    PrimitiveType_Softmax,
    PrimitiveType_SoftmaxCrossEntropyWithLogits,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SparseSoftmaxCrossEntropyWithLogits,
    PrimitiveType_SparseToDense,
    PrimitiveType_Split,
    PrimitiveType_Sqrt,
    PrimitiveType_Squeeze,
    PrimitiveType_Square,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Stack,
    PrimitiveType_StridedSlice,
    PrimitiveType_SubFusion,
    PrimitiveType_SubGrad,
    PrimitiveType_Switch,
    PrimitiveType_TensorListFromTensor,
    PrimitiveType_TensorListGetItem,
    PrimitiveType_TensorListReserve,
    PrimitiveType_TensorListSetItem,
    PrimitiveType_TensorListStack,
    PrimitiveType_TileFusion,
    PrimitiveType_TopKFusion,
    PrimitiveType_Transpose,
    PrimitiveType_Unique,
    PrimitiveType_UnsortedSegmentSum,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Unstack,
    PrimitiveType_LSTMGrad,
    PrimitiveType_Where,
    PrimitiveType_ZerosLike,
    PrimitiveType_Select,
    PrimitiveType_ScatterNdUpdate,
    PrimitiveType_GRU,
    PrimitiveType_NonZero,
    PrimitiveType_InvertPermutation,
    PrimitiveType_Size,
    PrimitiveType_RandomStandardNormal,
    PrimitiveType_CropAndResize,
    PrimitiveType_Erf,
    PrimitiveType_StridedSliceGrad,
    PrimitiveType_IsFinite,
    PrimitiveType_LinSpace,
    PrimitiveType_UniformReal,
    PrimitiveType_AbsGrad,
    PrimitiveType_RsqrtGrad,
    PrimitiveType_SqrtGrad,
    PrimitiveType_LayerNormGrad,
    PrimitiveType_ResizeGrad,
    PrimitiveType_Splice,
    PrimitiveType_LogSoftmax,
    PrimitiveType_Call,
    PrimitiveType_Custom,
    PrimitiveType_CumSum,
    PrimitiveType_SplitWithOverlap,
    PrimitiveType_GenOP,
    PrimitiveType_RaggedRange,
    PrimitiveType_GLU,
    PrimitiveType_TensorArray,
    PrimitiveType_TensorArrayRead,
    PrimitiveType_TensorArrayWrite,
    PrimitiveType_Affine,
    PrimitiveType_AllGather,
    PrimitiveType_ReduceScatter
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[204] = {
    "NONE",
    "Abs",
    "Activation",
    "ActivationGrad",
    "Adam",
    "AddFusion",
    "AdderFusion",
    "AddGrad",
    "AddN",
    "All",
    "ApplyMomentum",
    "ArgMaxFusion",
    "ArgMinFusion",
    "Assert",
    "Assign",
    "AssignAdd",
    "AudioSpectrogram",
    "AvgPoolFusion",
    "AvgPoolGrad",
    "BatchNorm",
    "BatchNormGrad",
    "BatchToSpace",
    "BatchToSpaceND",
    "BiasAdd",
    "BinaryCrossEntropy",
    "BinaryCrossEntropyGrad",
    "BiasAddGrad",
    "BroadcastTo",
    "Cast",
    "Ceil",
    "Clip",
    "Concat",
    "Attention",
    "Conv2DBackpropFilterFusion",
    "Conv2DBackpropInputFusion",
    "Conv2DFusion",
    "Conv2dTransposeFusion",
    "Cos",
    "ConstantOfShape",
    "Crop",
    "CustomExtractFeatures",
    "CustomNormalize",
    "CustomPredict",
    "DeConv2DGradFilter",
    "Depend",
    "DepthToSpace",
    "DetectionPostProcess",
    "DivFusion",
    "DivGrad",
    "Dropout",
    "DropoutGrad",
    "Elu",
    "Eltwise",
    "Equal",
    "EmbeddingLookupFusion",
    "ExpFusion",
    "ExpandDims",
    "FakeQuantWithMinMaxVars",
    "FakeQuantWithMinMaxVarsPerChannel",
    "FftReal",
    "FftImag",
    "Flatten",
    "FlattenGrad",
    "Floor",
    "FloorDiv",
    "FloorMod",
    "Fill",
    "FullConnection",
    "FusedBatchNorm",
    "Gather",
    "GatherNd",
    "Greater",
    "GreaterEqual",
    "HashtableLookup",
    "InstanceNorm",
    "LayerNormFusion",
    "LeakyRelu",
    "Less",
    "LessEqual",
    "Log",
    "LogGrad",
    "LogicalAnd",
    "LogicalNot",
    "LogicalOr",
    "LpNormalization",
    "LRN",
    "LshProjection",
    "LSTM",
    "L2NormalizeFusion",
    "MatMulFusion",
    "Maximum",
    "MaximumGrad",
    "MaxPoolFusion",
    "MaxPoolGrad",
    "SwitchLayer",
    "Mfcc",
    "Minimum",
    "MinimumGrad",
    "Mod",
    "MulFusion",
    "MulGrad",
    "Neg",
    "NegGrad",
    "NotEqual",
    "NonMaxSuppression",
    "OneHot",
    "OnesLike",
    "PadFusion",
    "PartialFusion",
    "PowerGrad",
    "PowFusion",
    "PriorBox",
    "PReLUFusion",
    "QuantDTypeCast",
    "Rank",
    "Range",
    "Reciprocal",
    "RealDiv",
    "ReduceFusion",
    "Reshape",
    "Resize",
    "ReverseSequence",
    "ReverseV2",
    "Rfft",
    "ROIPooling",
    "Round",
    "Rsqrt",
    "ScaleFusion",
    "ScatterNd",
    "SGD",
    "Shape",
    "SigmoidCrossEntropyWithLogits",
    "SigmoidCrossEntropyWithLogitsGrad",
    "Sin",
    "SkipGram",
    "SliceFusion",
    "SmoothL1Loss",
    "SmoothL1LossGrad",
    "Softmax",
    "SoftmaxCrossEntropyWithLogits",
    "SpaceToBatch",
    "SpaceToBatchND",
    "SpaceToDepth",
    "SparseSoftmaxCrossEntropyWithLogits",
    "SparseToDense",
    "Split",
    "Sqrt",
    "Squeeze",
    "Square",
    "SquaredDifference",
    "Stack",
    "StridedSlice",
    "SubFusion",
    "SubGrad",
    "Switch",
    "TensorListFromTensor",
    "TensorListGetItem",
    "TensorListReserve",
    "TensorListSetItem",
    "TensorListStack",
    "TileFusion",
    "TopKFusion",
    "Transpose",
    "Unique",
    "UnsortedSegmentSum",
    "Unsqueeze",
    "Unstack",
    "LSTMGrad",
    "Where",
    "ZerosLike",
    "Select",
    "ScatterNdUpdate",
    "GRU",
    "NonZero",
    "InvertPermutation",
    "Size",
    "RandomStandardNormal",
    "CropAndResize",
    "Erf",
    "StridedSliceGrad",
    "IsFinite",
    "LinSpace",
    "UniformReal",
    "AbsGrad",
    "RsqrtGrad",
    "SqrtGrad",
    "LayerNormGrad",
    "ResizeGrad",
    "Splice",
    "LogSoftmax",
    "Call",
    "Custom",
    "CumSum",
    "SplitWithOverlap",
    "GenOP",
    "RaggedRange",
    "GLU",
    "TensorArray",
    "TensorArrayRead",
    "TensorArrayWrite",
    "Affine",
    "AllGather",
    "ReduceScatter",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (flatbuffers::IsOutRange(e, PrimitiveType_NONE, PrimitiveType_ReduceScatter)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Adam> {
  static const PrimitiveType enum_value = PrimitiveType_Adam;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AddFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AdderFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AdderFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::All> {
  static const PrimitiveType enum_value = PrimitiveType_All;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ApplyMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMaxFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMaxFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ArgMinFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMinFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Assert> {
  static const PrimitiveType enum_value = PrimitiveType_Assert;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Assign> {
  static const PrimitiveType enum_value = PrimitiveType_Assign;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AssignAdd> {
  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AudioSpectrogram> {
  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolFusion> {
  static const PrimitiveType enum_value = PrimitiveType_AvgPoolFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AvgPoolGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AvgPoolGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchNormGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BatchToSpaceND> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BinaryCrossEntropyGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BiasAddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAddGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Attention> {
  static const PrimitiveType enum_value = PrimitiveType_Attention;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropFilterFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropFilterFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DBackpropInputFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DBackpropInputFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2DFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Conv2dTransposeFusion> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2dTransposeFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ConstantOfShape> {
  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomExtractFeatures> {
  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomNormalize> {
  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CustomPredict> {
  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DeConv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Depend> {
  static const PrimitiveType enum_value = PrimitiveType_Depend;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DivFusion> {
  static const PrimitiveType enum_value = PrimitiveType_DivFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::DropoutGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::EmbeddingLookupFusion> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ExpFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ExpFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FakeQuantWithMinMaxVarsPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVarsPerChannel;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FftReal> {
  static const PrimitiveType enum_value = PrimitiveType_FftReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FftImag> {
  static const PrimitiveType enum_value = PrimitiveType_FftImag;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FlattenGrad> {
  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::HashtableLookup> {
  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::InstanceNorm> {
  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormFusion> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNormFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LeakyRelu> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyRelu;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LpNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LRN> {
  static const PrimitiveType enum_value = PrimitiveType_LRN;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LshProjection> {
  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LSTM> {
  static const PrimitiveType enum_value = PrimitiveType_LSTM;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::L2NormalizeFusion> {
  static const PrimitiveType enum_value = PrimitiveType_L2NormalizeFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MatMulFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MatMulFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaximumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MaxPoolFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MaxPoolGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaxPoolGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SwitchLayer> {
  static const PrimitiveType enum_value = PrimitiveType_SwitchLayer;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Mfcc> {
  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MinimumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Mod> {
  static const PrimitiveType enum_value = PrimitiveType_Mod;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MulFusion> {
  static const PrimitiveType enum_value = PrimitiveType_MulFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NegGrad> {
  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NonMaxSuppression> {
  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::OnesLike> {
  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PadFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PadFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PartialFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PartialFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PowFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PowFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::PReLUFusion> {
  static const PrimitiveType enum_value = PrimitiveType_PReLUFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Reciprocal> {
  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ReduceFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReverseV2> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseV2;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rfft> {
  static const PrimitiveType enum_value = PrimitiveType_Rfft;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ROIPooling> {
  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScaleFusion> {
  static const PrimitiveType enum_value = PrimitiveType_ScaleFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNd> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterNd;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SGD> {
  static const PrimitiveType enum_value = PrimitiveType_SGD;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SigmoidCrossEntropyWithLogitsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SkipGram> {
  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SliceFusion> {
  static const PrimitiveType enum_value = PrimitiveType_SliceFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1Loss> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SmoothL1LossGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Softmax> {
  static const PrimitiveType enum_value = PrimitiveType_Softmax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SoftmaxCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SparseSoftmaxCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SubFusion> {
  static const PrimitiveType enum_value = PrimitiveType_SubFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Switch> {
  static const PrimitiveType enum_value = PrimitiveType_Switch;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListFromTensor> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListReserve> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListSetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorListStack> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TileFusion> {
  static const PrimitiveType enum_value = PrimitiveType_TileFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TopKFusion> {
  static const PrimitiveType enum_value = PrimitiveType_TopKFusion;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::UnsortedSegmentSum> {
  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LSTMGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LSTMGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ScatterNdUpdate> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterNdUpdate;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GRU> {
  static const PrimitiveType enum_value = PrimitiveType_GRU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::NonZero> {
  static const PrimitiveType enum_value = PrimitiveType_NonZero;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::InvertPermutation> {
  static const PrimitiveType enum_value = PrimitiveType_InvertPermutation;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Size> {
  static const PrimitiveType enum_value = PrimitiveType_Size;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RandomStandardNormal> {
  static const PrimitiveType enum_value = PrimitiveType_RandomStandardNormal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CropAndResize> {
  static const PrimitiveType enum_value = PrimitiveType_CropAndResize;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Erf> {
  static const PrimitiveType enum_value = PrimitiveType_Erf;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::StridedSliceGrad> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSliceGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::IsFinite> {
  static const PrimitiveType enum_value = PrimitiveType_IsFinite;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LinSpace> {
  static const PrimitiveType enum_value = PrimitiveType_LinSpace;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::UniformReal> {
  static const PrimitiveType enum_value = PrimitiveType_UniformReal;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AbsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AbsGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RsqrtGrad> {
  static const PrimitiveType enum_value = PrimitiveType_RsqrtGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SqrtGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SqrtGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LayerNormGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNormGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ResizeGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ResizeGrad;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Splice> {
  static const PrimitiveType enum_value = PrimitiveType_Splice;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::LogSoftmax> {
  static const PrimitiveType enum_value = PrimitiveType_LogSoftmax;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Call> {
  static const PrimitiveType enum_value = PrimitiveType_Call;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Custom> {
  static const PrimitiveType enum_value = PrimitiveType_Custom;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::CumSum> {
  static const PrimitiveType enum_value = PrimitiveType_CumSum;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::SplitWithOverlap> {
  static const PrimitiveType enum_value = PrimitiveType_SplitWithOverlap;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GenOP> {
  static const PrimitiveType enum_value = PrimitiveType_GenOP;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::RaggedRange> {
  static const PrimitiveType enum_value = PrimitiveType_RaggedRange;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::GLU> {
  static const PrimitiveType enum_value = PrimitiveType_GLU;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArray> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArray;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayRead> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArrayRead;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::TensorArrayWrite> {
  static const PrimitiveType enum_value = PrimitiveType_TensorArrayWrite;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::Affine> {
  static const PrimitiveType enum_value = PrimitiveType_Affine;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::AllGather> {
  static const PrimitiveType enum_value = PrimitiveType_AllGather;
};

template<> struct PrimitiveTypeTraits<mindspore::schema::ReduceScatter> {
  static const PrimitiveType enum_value = PrimitiveType_ReduceScatter;
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsBuilder {
  typedef Abs Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Abs> CreateAbs(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10,
    VT_APPROXIMATE = 12
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, 0.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 0.0f);
  }
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
};

struct ActivationBuilder {
  typedef Activation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Activation::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.0f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, 0.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 0.0f);
  }
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(Activation::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool approximate = false) {
  ActivationBuilder builder_(_fbb);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_approximate(approximate);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ActivationGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ActivationGradBuilder {
  typedef ActivationGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(ActivationGrad::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.0f);
  }
  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ActivationGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f) {
  ActivationGradBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_LOCKING = 4,
    VT_USE_NESTEROV = 6
  };
  bool use_locking() const {
    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
  }
  bool use_nesterov() const {
    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
           verifier.EndTable();
  }
};

struct AdamBuilder {
  typedef Adam Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_locking(bool use_locking) {
    fbb_.AddElement<uint8_t>(Adam::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
  }
  void add_use_nesterov(bool use_nesterov) {
    fbb_.AddElement<uint8_t>(Adam::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
  }
  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Adam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adam>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adam> CreateAdam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_locking = false,
    bool use_nesterov = false) {
  AdamBuilder builder_(_fbb);
  builder_.add_use_nesterov(use_nesterov);
  builder_.add_use_locking(use_locking);
  return builder_.Finish();
}

struct AddFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct AddFusionBuilder {
  typedef AddFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AddFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AddFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddFusion> CreateAddFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AddFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct AdderFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AdderFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_GROUP = 16,
    VT_IN_CHANNEL = 18,
    VT_OUT_CHANNEL = 20,
    VT_ACTIVATION_TYPE = 22
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct AdderFusionBuilder {
  typedef AdderFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AdderFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AdderFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(AdderFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(AdderFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AdderFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(AdderFusion::VT_PAD_LIST, pad_list);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(AdderFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AdderFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AdderFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AdderFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AdderFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AdderFusion> CreateAdderFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AdderFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AdderFusion> CreateAdderFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateAdderFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      group,
      in_channel,
      out_channel,
      activation_type);
}

struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddGradBuilder {
  typedef AddGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddGrad> CreateAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AddNBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddNBuilder {
  typedef AddN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AddN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddN>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddN> CreateAddN(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNBuilder builder_(_fbb);
  return builder_.Finish();
}

struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4
  };
  int64_t keep_dims() const {
    return GetField<int64_t>(VT_KEEP_DIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
};

struct AllBuilder {
  typedef All Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(int64_t keep_dims) {
    fbb_.AddElement<int64_t>(All::VT_KEEP_DIMS, keep_dims, 0);
  }
  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<All> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<All>(end);
    return o;
  }
};

inline flatbuffers::Offset<All> CreateAll(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t keep_dims = 0) {
  AllBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ApplyMomentumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USE_NESTEROV = 4,
    VT_USE_LOCKING = 6,
    VT_GRADIENT_SCALE = 8
  };
  bool use_nesterov() const {
    return GetField<uint8_t>(VT_USE_NESTEROV, 0) != 0;
  }
  bool use_locking() const {
    return GetField<uint8_t>(VT_USE_LOCKING, 0) != 0;
  }
  float gradient_scale() const {
    return GetField<float>(VT_GRADIENT_SCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USE_NESTEROV) &&
           VerifyField<uint8_t>(verifier, VT_USE_LOCKING) &&
           VerifyField<float>(verifier, VT_GRADIENT_SCALE) &&
           verifier.EndTable();
  }
};

struct ApplyMomentumBuilder {
  typedef ApplyMomentum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_use_nesterov(bool use_nesterov) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_NESTEROV, static_cast<uint8_t>(use_nesterov), 0);
  }
  void add_use_locking(bool use_locking) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USE_LOCKING, static_cast<uint8_t>(use_locking), 0);
  }
  void add_gradient_scale(float gradient_scale) {
    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENT_SCALE, gradient_scale, 0.0f);
  }
  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ApplyMomentum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ApplyMomentum>(end);
    return o;
  }
};

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool use_nesterov = false,
    bool use_locking = false,
    float gradient_scale = 0.0f) {
  ApplyMomentumBuilder builder_(_fbb);
  builder_.add_gradient_scale(gradient_scale);
  builder_.add_use_locking(use_locking);
  builder_.add_use_nesterov(use_nesterov);
  return builder_.Finish();
}

struct ArgMaxFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMaxFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_TOP_K = 6,
    VT_KEEP_DIMS = 8,
    VT_OUT_MAX_VALUE = 10
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t top_k() const {
    return GetField<int64_t>(VT_TOP_K, 1LL);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool out_max_value() const {
    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_TOP_K) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
           verifier.EndTable();
  }
};

struct ArgMaxFusionBuilder {
  typedef ArgMaxFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_AXIS, axis, 0);
  }
  void add_top_k(int64_t top_k) {
    fbb_.AddElement<int64_t>(ArgMaxFusion::VT_TOP_K, top_k, 1LL);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_out_max_value(bool out_max_value) {
    fbb_.AddElement<uint8_t>(ArgMaxFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
  }
  explicit ArgMaxFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMaxFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxFusion> CreateArgMaxFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t top_k = 1LL,
    bool keep_dims = false,
    bool out_max_value = false) {
  ArgMaxFusionBuilder builder_(_fbb);
  builder_.add_top_k(top_k);
  builder_.add_axis(axis);
  builder_.add_out_max_value(out_max_value);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct ArgMinFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArgMinFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_TOP_K = 6,
    VT_KEEP_DIMS = 8,
    VT_OUT_MAX_VALUE = 10
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t top_k() const {
    return GetField<int64_t>(VT_TOP_K, 0);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool out_max_value() const {
    return GetField<uint8_t>(VT_OUT_MAX_VALUE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_TOP_K) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_MAX_VALUE) &&
           verifier.EndTable();
  }
};

struct ArgMinFusionBuilder {
  typedef ArgMinFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ArgMinFusion::VT_AXIS, axis, 0);
  }
  void add_top_k(int64_t top_k) {
    fbb_.AddElement<int64_t>(ArgMinFusion::VT_TOP_K, top_k, 0);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_out_max_value(bool out_max_value) {
    fbb_.AddElement<uint8_t>(ArgMinFusion::VT_OUT_MAX_VALUE, static_cast<uint8_t>(out_max_value), 0);
  }
  explicit ArgMinFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ArgMinFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinFusion> CreateArgMinFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t top_k = 0,
    bool keep_dims = false,
    bool out_max_value = false) {
  ArgMinFusionBuilder builder_(_fbb);
  builder_.add_top_k(top_k);
  builder_.add_axis(axis);
  builder_.add_out_max_value(out_max_value);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssertBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUMMARIZE = 4
  };
  int64_t summarize() const {
    return GetField<int64_t>(VT_SUMMARIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SUMMARIZE) &&
           verifier.EndTable();
  }
};

struct AssertBuilder {
  typedef Assert Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_summarize(int64_t summarize) {
    fbb_.AddElement<int64_t>(Assert::VT_SUMMARIZE, summarize, 0);
  }
  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assert> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assert>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assert> CreateAssert(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t summarize = 0) {
  AssertBuilder builder_(_fbb);
  builder_.add_summarize(summarize);
  return builder_.Finish();
}

struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AssignBuilder {
  typedef Assign Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Assign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assign>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assign> CreateAssign(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AssignAddBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AssignAddBuilder {
  typedef AssignAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AssignAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignAddBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AudioSpectrogramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOW_SIZE = 4,
    VT_STRIDE = 6,
    VT_MAG_SQUARE = 8
  };
  int64_t window_size() const {
    return GetField<int64_t>(VT_WINDOW_SIZE, 0);
  }
  int64_t stride() const {
    return GetField<int64_t>(VT_STRIDE, 0);
  }
  bool mag_square() const {
    return GetField<uint8_t>(VT_MAG_SQUARE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_WINDOW_SIZE) &&
           VerifyField<int64_t>(verifier, VT_STRIDE) &&
           VerifyField<uint8_t>(verifier, VT_MAG_SQUARE) &&
           verifier.EndTable();
  }
};

struct AudioSpectrogramBuilder {
  typedef AudioSpectrogram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_window_size(int64_t window_size) {
    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_WINDOW_SIZE, window_size, 0);
  }
  void add_stride(int64_t stride) {
    fbb_.AddElement<int64_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
  }
  void add_mag_square(bool mag_square) {
    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAG_SQUARE, static_cast<uint8_t>(mag_square), 0);
  }
  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AudioSpectrogram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t window_size = 0,
    int64_t stride = 0,
    bool mag_square = false) {
  AudioSpectrogramBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_window_size(window_size);
  builder_.add_mag_square(mag_square);
  return builder_.Finish();
}

struct AvgPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AvgPoolFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD = 8,
    VT_PAD_MODE = 10,
    VT_ROUND_MODE = 12,
    VT_FORMAT = 14,
    VT_GLOBAL = 16,
    VT_ACTIVATION_TYPE = 18
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct AvgPoolFusionBuilder {
  typedef AvgPoolFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AvgPoolFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(AvgPoolFusion::VT_STRIDES, strides);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(AvgPoolFusion::VT_PAD, pad);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AvgPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(AvgPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(AvgPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit AvgPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AvgPoolFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvgPoolFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  AvgPoolFusionBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_pad(pad);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvgPoolFusion> CreateAvgPoolFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  return mindspore::schema::CreateAvgPoolFusion(
      _fbb,
      kernel_size__,
      strides__,
      pad__,
      pad_mode,
      round_mode,
      format,
      global,
      activation_type);
}

struct AvgPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AvgPoolGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD_MODE = 8,
    VT_FORMAT = 10
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct AvgPoolGradBuilder {
  typedef AvgPoolGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(AvgPoolGrad::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(AvgPoolGrad::VT_STRIDES, strides);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(AvgPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(AvgPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit AvgPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AvgPoolGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AvgPoolGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  AvgPoolGradBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AvgPoolGrad> CreateAvgPoolGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return mindspore::schema::CreateAvgPoolGrad(
      _fbb,
      kernel_size__,
      strides__,
      pad_mode,
      format);
}

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_FORMAT = 6,
    VT_IS_TRAINING = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool is_training() const {
    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
           verifier.EndTable();
  }
};

struct BatchNormBuilder {
  typedef BatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(BatchNorm::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_is_training(bool is_training) {
    fbb_.AddElement<uint8_t>(BatchNorm::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool is_training = false) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_epsilon(epsilon);
  builder_.add_is_training(is_training);
  return builder_.Finish();
}

struct BatchNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchNormGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct BatchNormGradBuilder {
  typedef BatchNormGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNormGrad::VT_EPSILON, epsilon, 0.0f);
  }
  explicit BatchNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchNormGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormGrad> CreateBatchNormGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f) {
  BatchNormGradBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int64_t> *block_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  const mindspore::schema::Vec2D *crops() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
           verifier.VerifyVector(block_size()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyTable(crops()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceBuilder {
  typedef BatchToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCK_SIZE, block_size);
  }
  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_size = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
  return mindspore::schema::CreateBatchToSpace(
      _fbb,
      block_size__,
      crops);
}

struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BatchToSpaceNDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int64_t> *block_shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  const mindspore::schema::Vec2D *crops() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
           verifier.VerifyVector(block_shape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyTable(crops()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceNDBuilder {
  typedef BatchToSpaceND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
    fbb_.AddOffset(BatchToSpaceND::VT_BLOCK_SHAPE, block_shape);
  }
  void add_crops(flatbuffers::Offset<mindspore::schema::Vec2D> crops) {
    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
  }
  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BatchToSpaceND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  BatchToSpaceNDBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_block_shape(block_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_shape = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> crops = 0) {
  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
  return mindspore::schema::CreateBatchToSpaceND(
      _fbb,
      block_shape__,
      crops);
}

struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasAddBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct BiasAddBuilder {
  typedef BiasAdd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(BiasAdd::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  BiasAddBuilder builder_(_fbb);
  builder_.add_format(format);
  return builder_.Finish();
}

struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  mindspore::schema::Reduction reduction() const {
    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
};

struct BinaryCrossEntropyBuilder {
  typedef BinaryCrossEntropy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(mindspore::schema::Reduction reduction) {
    fbb_.AddElement<int8_t>(BinaryCrossEntropy::VT_REDUCTION, static_cast<int8_t>(reduction), 0);
  }
  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_REDUCTION_SUM) {
  BinaryCrossEntropyBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BinaryCrossEntropyGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  mindspore::schema::Reduction reduction() const {
    return static_cast<mindspore::schema::Reduction>(GetField<int8_t>(VT_REDUCTION, 1));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
};

struct BinaryCrossEntropyGradBuilder {
  typedef BinaryCrossEntropyGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(mindspore::schema::Reduction reduction) {
    fbb_.AddElement<int8_t>(BinaryCrossEntropyGrad::VT_REDUCTION, static_cast<int8_t>(reduction), 1);
  }
  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Reduction reduction = mindspore::schema::Reduction_MEAN) {
  BinaryCrossEntropyGradBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

struct BiasAddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BiasAddGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BiasAddGradBuilder {
  typedef BiasAddGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BiasAddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BiasAddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAddGrad> CreateBiasAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BiasAddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BroadcastToBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4
  };
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
};

struct BroadcastToBuilder {
  typedef BroadcastTo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(BroadcastTo::VT_SHAPE, shape);
  }
  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BroadcastTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastTo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
  BroadcastToBuilder builder_(_fbb);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return mindspore::schema::CreateBroadcastTo(
      _fbb,
      shape__);
}

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CastBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CastBuilder {
  typedef Cast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CastBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CeilBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CeilBuilder {
  typedef Ceil Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Ceil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ceil>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ceil> CreateCeil(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CeilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ClipBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<float>(verifier, VT_MIN) &&
           verifier.EndTable();
  }
};

struct ClipBuilder {
  typedef Clip Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(float max) {
    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
  }
  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Clip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Clip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Clip> CreateClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max = 0.0f,
    float min = 0.0f) {
  ClipBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConcatBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct ConcatBuilder {
  typedef Concat Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Concat::VT_AXIS, axis, 0);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Attention FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttentionBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AttentionBuilder {
  typedef Attention Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AttentionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attention> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attention>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attention> CreateAttention(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AttentionBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Conv2DBackpropFilterFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DBackpropFilterFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_MODE = 16,
    VT_GROUP = 18,
    VT_IN_CHANNEL = 20,
    VT_OUT_CHANNEL = 22,
    VT_ACTIVATION_TYPE = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DBackpropFilterFusionBuilder {
  typedef Conv2DBackpropFilterFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DBackpropFilterFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DBackpropFilterFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropFilterFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DBackpropFilterFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DBackpropFilterFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DBackpropFilterFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DBackpropFilterFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DBackpropFilterFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DBackpropFilterFusion> CreateConv2DBackpropFilterFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DBackpropFilterFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

struct Conv2DBackpropInputFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DBackpropInputFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD = 14,
    VT_PAD_LIST = 16,
    VT_MODE = 18,
    VT_GROUP = 20,
    VT_IN_CHANNEL = 22,
    VT_OUT_CHANNEL = 24,
    VT_ACTIVATION_TYPE = 26
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DBackpropInputFusionBuilder {
  typedef Conv2DBackpropInputFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DBackpropInputFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD, pad);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DBackpropInputFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DBackpropInputFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DBackpropInputFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DBackpropInputFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DBackpropInputFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DBackpropInputFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DBackpropInputFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_pad(pad);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DBackpropInputFusion> CreateConv2DBackpropInputFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad = nullptr,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DBackpropInputFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad__,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

struct Conv2DFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2DFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD_LIST = 14,
    VT_MODE = 16,
    VT_GROUP = 18,
    VT_IN_CHANNEL = 20,
    VT_OUT_CHANNEL = 22,
    VT_ACTIVATION_TYPE = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DFusionBuilder {
  typedef Conv2DFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2DFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2DFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2DFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2DFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2DFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2DFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2DFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2DFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit Conv2DFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2DFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  Conv2DFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DFusion> CreateConv2DFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  return mindspore::schema::CreateConv2DFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type);
}

struct Conv2dTransposeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Conv2dTransposeFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_KERNEL_SIZE = 6,
    VT_STRIDE = 8,
    VT_DILATION = 10,
    VT_PAD_MODE = 12,
    VT_PAD = 14,
    VT_PAD_LIST = 16,
    VT_MODE = 18,
    VT_GROUP = 20,
    VT_IN_CHANNEL = 22,
    VT_OUT_CHANNEL = 24,
    VT_ACTIVATION_TYPE = 26,
    VT_OUTPUT_PADDINGS = 28
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  const flatbuffers::Vector<int64_t> *output_paddings() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OUTPUT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyOffset(verifier, VT_OUTPUT_PADDINGS) &&
           verifier.VerifyVector(output_paddings()) &&
           verifier.EndTable();
  }
};

struct Conv2dTransposeFusionBuilder {
  typedef Conv2dTransposeFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Conv2dTransposeFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD, pad);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(Conv2dTransposeFusion::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Conv2dTransposeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_output_paddings(flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings) {
    fbb_.AddOffset(Conv2dTransposeFusion::VT_OUTPUT_PADDINGS, output_paddings);
  }
  explicit Conv2dTransposeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Conv2dTransposeFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2dTransposeFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> output_paddings = 0) {
  Conv2dTransposeFusionBuilder builder_(_fbb);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_output_paddings(output_paddings);
  builder_.add_pad_list(pad_list);
  builder_.add_pad(pad);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2dTransposeFusion> CreateConv2dTransposeFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad = nullptr,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    const std::vector<int64_t> *output_paddings = nullptr) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto output_paddings__ = output_paddings ? _fbb.CreateVector<int64_t>(*output_paddings) : 0;
  return mindspore::schema::CreateConv2dTransposeFusion(
      _fbb,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad__,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      activation_type,
      output_paddings__);
}

struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CosBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CosBuilder {
  typedef Cos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cos> CreateCos(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ConstantOfShapeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA_TYPE = 4,
    VT_VALUE = 6
  };
  int64_t data_type() const {
    return GetField<int64_t>(VT_DATA_TYPE, 0);
  }
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DATA_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ConstantOfShapeBuilder {
  typedef ConstantOfShape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data_type(int64_t data_type) {
    fbb_.AddElement<int64_t>(ConstantOfShape::VT_DATA_TYPE, data_type, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
  }
  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ConstantOfShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantOfShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data_type = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  ConstantOfShapeBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t data_type = 0,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return mindspore::schema::CreateConstantOfShape(
      _fbb,
      data_type,
      value__);
}

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSETS = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
};

struct CropBuilder {
  typedef Crop Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_offsets(offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<int64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
  return mindspore::schema::CreateCrop(
      _fbb,
      axis,
      offsets__);
}

struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomExtractFeaturesBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CustomExtractFeaturesBuilder {
  typedef CustomExtractFeatures Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomExtractFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomExtractFeaturesBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomNormalizeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CustomNormalizeBuilder {
  typedef CustomNormalize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomNormalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomNormalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomNormalizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomPredictBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_NUM = 4,
    VT_WEIGHT_THRESHOLD = 6
  };
  int64_t output_num() const {
    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
  }
  float weight_threshold() const {
    return GetField<float>(VT_WEIGHT_THRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
           VerifyField<float>(verifier, VT_WEIGHT_THRESHOLD) &&
           verifier.EndTable();
  }
};

struct CustomPredictBuilder {
  typedef CustomPredict Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_num(int64_t output_num) {
    fbb_.AddElement<int64_t>(CustomPredict::VT_OUTPUT_NUM, output_num, 0);
  }
  void add_weight_threshold(float weight_threshold) {
    fbb_.AddElement<float>(CustomPredict::VT_WEIGHT_THRESHOLD, weight_threshold, 0.0f);
  }
  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CustomPredict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomPredict>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    float weight_threshold = 0.0f) {
  CustomPredictBuilder builder_(_fbb);
  builder_.add_output_num(output_num);
  builder_.add_weight_threshold(weight_threshold);
  return builder_.Finish();
}

struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DeConv2DGradFilterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IN_CHANNEL = 4,
    VT_OUT_CHANNEL = 6,
    VT_KERNEL_SIZE = 8,
    VT_PAD_MODE = 10,
    VT_PAD_LIST = 12,
    VT_STRIDE = 14,
    VT_DILATION = 16,
    VT_GROUP = 18,
    VT_FORMAT = 20,
    VT_ACTIVATION_TYPE = 22
  };
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct DeConv2DGradFilterBuilder {
  typedef DeConv2DGradFilter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_KERNEL_SIZE, kernel_size);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_PAD_LIST, pad_list);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(DeConv2DGradFilter::VT_DILATION, dilation);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    int64_t group = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  DeConv2DGradFilterBuilder builder_(_fbb);
  builder_.add_group(group);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_format(format);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_pad_list(pad_list);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    const std::vector<int64_t> *kernel_size = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    int64_t group = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  return mindspore::schema::CreateDeConv2DGradFilter(
      _fbb,
      in_channel,
      out_channel,
      kernel_size__,
      pad_mode,
      pad_list__,
      stride__,
      dilation__,
      group,
      format,
      activation_type);
}

struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DependBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DependBuilder {
  typedef Depend Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Depend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Depend>(end);
    return o;
  }
};

inline flatbuffers::Offset<Depend> CreateDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DependBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DepthToSpaceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_FORMAT = 6
  };
  int64_t block_size() const {
    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceBuilder {
  typedef DepthToSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int64_t block_size) {
    fbb_.AddElement<int64_t>(DepthToSpace::VT_BLOCK_SIZE, block_size, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DepthToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t block_size = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  DepthToSpaceBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_format(format);
  return builder_.Finish();
}

struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DetectionPostProcessBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_INPUT_SIZE = 6,
    VT_SCALE = 8,
    VT_NMS_IOU_THRESHOLD = 10,
    VT_NMS_SCORE_THRESHOLD = 12,
    VT_MAX_DETECTIONS = 14,
    VT_DETECTIONS_PER_CLASS = 16,
    VT_MAX_CLASSES_PER_DETECTION = 18,
    VT_NUM_CLASSES = 20,
    VT_USE_REGULAR_NMS = 22,
    VT_OUT_QUANTIZED = 24
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  float nms_iou_threshold() const {
    return GetField<float>(VT_NMS_IOU_THRESHOLD, 0.0f);
  }
  float nms_score_threshold() const {
    return GetField<float>(VT_NMS_SCORE_THRESHOLD, 0.0f);
  }
  int64_t max_detections() const {
    return GetField<int64_t>(VT_MAX_DETECTIONS, 0);
  }
  int64_t detections_per_class() const {
    return GetField<int64_t>(VT_DETECTIONS_PER_CLASS, 0);
  }
  int64_t max_classes_per_detection() const {
    return GetField<int64_t>(VT_MAX_CLASSES_PER_DETECTION, 0);
  }
  int64_t num_classes() const {
    return GetField<int64_t>(VT_NUM_CLASSES, 0);
  }
  bool use_regular_nms() const {
    return GetField<uint8_t>(VT_USE_REGULAR_NMS, 0) != 0;
  }
  bool out_quantized() const {
    return GetField<uint8_t>(VT_OUT_QUANTIZED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyField<float>(verifier, VT_NMS_IOU_THRESHOLD) &&
           VerifyField<float>(verifier, VT_NMS_SCORE_THRESHOLD) &&
           VerifyField<int64_t>(verifier, VT_MAX_DETECTIONS) &&
           VerifyField<int64_t>(verifier, VT_DETECTIONS_PER_CLASS) &&
           VerifyField<int64_t>(verifier, VT_MAX_CLASSES_PER_DETECTION) &&
           VerifyField<int64_t>(verifier, VT_NUM_CLASSES) &&
           VerifyField<uint8_t>(verifier, VT_USE_REGULAR_NMS) &&
           VerifyField<uint8_t>(verifier, VT_OUT_QUANTIZED) &&
           verifier.EndTable();
  }
};

struct DetectionPostProcessBuilder {
  typedef DetectionPostProcess Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_INPUT_SIZE, input_size, 0);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(DetectionPostProcess::VT_SCALE, scale);
  }
  void add_nms_iou_threshold(float nms_iou_threshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_IOU_THRESHOLD, nms_iou_threshold, 0.0f);
  }
  void add_nms_score_threshold(float nms_score_threshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMS_SCORE_THRESHOLD, nms_score_threshold, 0.0f);
  }
  void add_max_detections(int64_t max_detections) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_DETECTIONS, max_detections, 0);
  }
  void add_detections_per_class(int64_t detections_per_class) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONS_PER_CLASS, detections_per_class, 0);
  }
  void add_max_classes_per_detection(int64_t max_classes_per_detection) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAX_CLASSES_PER_DETECTION, max_classes_per_detection, 0);
  }
  void add_num_classes(int64_t num_classes) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUM_CLASSES, num_classes, 0);
  }
  void add_use_regular_nms(bool use_regular_nms) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USE_REGULAR_NMS, static_cast<uint8_t>(use_regular_nms), 0);
  }
  void add_out_quantized(bool out_quantized) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUT_QUANTIZED, static_cast<uint8_t>(out_quantized), 0);
  }
  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DetectionPostProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    int64_t input_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    float nms_iou_threshold = 0.0f,
    float nms_score_threshold = 0.0f,
    int64_t max_detections = 0,
    int64_t detections_per_class = 0,
    int64_t max_classes_per_detection = 0,
    int64_t num_classes = 0,
    bool use_regular_nms = false,
    bool out_quantized = false) {
  DetectionPostProcessBuilder builder_(_fbb);
  builder_.add_num_classes(num_classes);
  builder_.add_max_classes_per_detection(max_classes_per_detection);
  builder_.add_detections_per_class(detections_per_class);
  builder_.add_max_detections(max_detections);
  builder_.add_input_size(input_size);
  builder_.add_nms_score_threshold(nms_score_threshold);
  builder_.add_nms_iou_threshold(nms_iou_threshold);
  builder_.add_scale(scale);
  builder_.add_format(format);
  builder_.add_out_quantized(out_quantized);
  builder_.add_use_regular_nms(use_regular_nms);
  return builder_.Finish();
}

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcessDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    int64_t input_size = 0,
    const std::vector<float> *scale = nullptr,
    float nms_iou_threshold = 0.0f,
    float nms_score_threshold = 0.0f,
    int64_t max_detections = 0,
    int64_t detections_per_class = 0,
    int64_t max_classes_per_detection = 0,
    int64_t num_classes = 0,
    bool use_regular_nms = false,
    bool out_quantized = false) {
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return mindspore::schema::CreateDetectionPostProcess(
      _fbb,
      format,
      input_size,
      scale__,
      nms_iou_threshold,
      nms_score_threshold,
      max_detections,
      detections_per_class,
      max_classes_per_detection,
      num_classes,
      use_regular_nms,
      out_quantized);
}

struct DivFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct DivFusionBuilder {
  typedef DivFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(DivFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit DivFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivFusion> CreateDivFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  DivFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DivGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DivGradBuilder {
  typedef DivGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DivGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivGrad> CreateDivGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_PROB = 4
  };
  float keep_prob() const {
    return GetField<float>(VT_KEEP_PROB, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KEEP_PROB) &&
           verifier.EndTable();
  }
};

struct DropoutBuilder {
  typedef Dropout Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_prob(float keep_prob) {
    fbb_.AddElement<float>(Dropout::VT_KEEP_PROB, keep_prob, 0.5f);
  }
  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dropout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dropout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dropout> CreateDropout(
    flatbuffers::FlatBufferBuilder &_fbb,
    float keep_prob = 0.5f) {
  DropoutBuilder builder_(_fbb);
  builder_.add_keep_prob(keep_prob);
  return builder_.Finish();
}

struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DropoutGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_PROB = 4
  };
  float keep_prob() const {
    return GetField<float>(VT_KEEP_PROB, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_KEEP_PROB) &&
           verifier.EndTable();
  }
};

struct DropoutGradBuilder {
  typedef DropoutGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_prob(float keep_prob) {
    fbb_.AddElement<float>(DropoutGrad::VT_KEEP_PROB, keep_prob, 0.0f);
  }
  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DropoutGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropoutGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float keep_prob = 0.0f) {
  DropoutGradBuilder builder_(_fbb);
  builder_.add_keep_prob(keep_prob);
  return builder_.Finish();
}

struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EluBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct EluBuilder {
  typedef Elu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 0.0f);
  }
  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Elu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elu> CreateElu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  EluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EltwiseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  mindspore::schema::EltwiseMode mode() const {
    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct EltwiseBuilder {
  typedef Eltwise Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(mindspore::schema::EltwiseMode mode) {
    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::EltwiseMode mode = mindspore::schema::EltwiseMode_PROD) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EqualBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EqualBuilder {
  typedef Equal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equal> CreateEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmbeddingLookupFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EmbeddingLookupFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX_NORM = 4
  };
  float max_norm() const {
    return GetField<float>(VT_MAX_NORM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX_NORM) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupFusionBuilder {
  typedef EmbeddingLookupFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max_norm(float max_norm) {
    fbb_.AddElement<float>(EmbeddingLookupFusion::VT_MAX_NORM, max_norm, 0.0f);
  }
  explicit EmbeddingLookupFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<EmbeddingLookupFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupFusion> CreateEmbeddingLookupFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max_norm = 0.0f) {
  EmbeddingLookupFusionBuilder builder_(_fbb);
  builder_.add_max_norm(max_norm);
  return builder_.Finish();
}

struct ExpFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float base() const {
    return GetField<float>(VT_BASE, -1.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BASE) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct ExpFusionBuilder {
  typedef ExpFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(float base) {
    fbb_.AddElement<float>(ExpFusion::VT_BASE, base, -1.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ExpFusion::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(ExpFusion::VT_SHIFT, shift, 0.0f);
  }
  explicit ExpFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpFusion> CreateExpFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float base = -1.0f,
    float scale = 1.0f,
    float shift = 0.0f) {
  ExpFusionBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_base(base);
  return builder_.Finish();
}

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExpandDimsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpandDimsBuilder {
  typedef ExpandDims Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxVarsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BITS = 4,
    VT_NARROW_RANGE = 6
  };
  int64_t num_bits() const {
    return GetField<int64_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxVarsBuilder {
  typedef FakeQuantWithMinMaxVars Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_bits(int64_t num_bits) {
    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVars::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxVarsPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FakeQuantWithMinMaxVarsPerChannelBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_BITS = 4,
    VT_NARROW_RANGE = 6
  };
  int64_t num_bits() const {
    return GetField<int64_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxVarsPerChannelBuilder {
  typedef FakeQuantWithMinMaxVarsPerChannel Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_bits(int64_t num_bits) {
    fbb_.AddElement<int64_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVarsPerChannel::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantWithMinMaxVarsPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVarsPerChannel> CreateFakeQuantWithMinMaxVarsPerChannel(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantWithMinMaxVarsPerChannelBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftRealBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FftRealBuilder {
  typedef FftReal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftReal> CreateFftReal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftRealBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FftImagBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FftImagBuilder {
  typedef FftImag Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FftImag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftImag>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftImag> CreateFftImag(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftImagBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FlattenBuilder {
  typedef Flatten Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FlattenGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FlattenGradBuilder {
  typedef FlattenGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FlattenGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorBuilder {
  typedef Floor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorDivBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorDivBuilder {
  typedef FloorDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FloorModBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorModBuilder {
  typedef FloorMod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FloorMod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorMod>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorMod> CreateFloorMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FillBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  typedef Fill Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FullConnectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HAS_BIAS = 4,
    VT_USE_AXIS = 6,
    VT_AXIS = 8,
    VT_ACTIVATION_TYPE = 10
  };
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool use_axis() const {
    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct FullConnectionBuilder {
  typedef FullConnection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_use_axis(bool use_axis) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(FullConnection::VT_AXIS, axis, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FullConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnection> CreateFullConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  FullConnectionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  builder_.add_use_axis(use_axis);
  builder_.add_has_bias(has_bias);
  return builder_.Finish();
}

struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FusedBatchNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6,
    VT_MODE = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct FusedBatchNormBuilder {
  typedef FusedBatchNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.0001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(FusedBatchNorm::VT_MODE, mode, 0);
  }
  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<FusedBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    int64_t mode = 0) {
  FusedBatchNormBuilder builder_(_fbb);
  builder_.add_mode(mode);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GatherBuilder {
  typedef Gather Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GatherNdBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GatherNdBuilder {
  typedef GatherNd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GatherNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNd> CreateGatherNd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterBuilder {
  typedef Greater Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greater> CreateGreater(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GreaterEqualBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterEqualBuilder {
  typedef GreaterEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef HashtableLookupBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HashtableLookupBuilder {
  typedef HashtableLookup Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<HashtableLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableLookupBuilder builder_(_fbb);
  return builder_.Finish();
}

struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InstanceNormBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct InstanceNormBuilder {
  typedef InstanceNorm Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.0f);
  }
  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InstanceNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.0f) {
  InstanceNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct LayerNormFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_NORM_AXIS = 4,
    VT_EPSILON = 6,
    VT_ELEMENTWISE_AFFINE = 8,
    VT_BEGIN_PARAMS_AXIS = 10
  };
  int64_t begin_norm_axis() const {
    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool elementwise_affine() const {
    return GetField<uint8_t>(VT_ELEMENTWISE_AFFINE, 0) != 0;
  }
  int64_t begin_params_axis() const {
    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENTWISE_AFFINE) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
           verifier.EndTable();
  }
};

struct LayerNormFusionBuilder {
  typedef LayerNormFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_norm_axis(int64_t begin_norm_axis) {
    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNormFusion::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_elementwise_affine(bool elementwise_affine) {
    fbb_.AddElement<uint8_t>(LayerNormFusion::VT_ELEMENTWISE_AFFINE, static_cast<uint8_t>(elementwise_affine), 0);
  }
  void add_begin_params_axis(int64_t begin_params_axis) {
    fbb_.AddElement<int64_t>(LayerNormFusion::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
  }
  explicit LayerNormFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNormFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNormFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNormFusion> CreateLayerNormFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_norm_axis = 0,
    float epsilon = 0.00001f,
    bool elementwise_affine = false,
    int64_t begin_params_axis = 0) {
  LayerNormFusionBuilder builder_(_fbb);
  builder_.add_begin_params_axis(begin_params_axis);
  builder_.add_begin_norm_axis(begin_norm_axis);
  builder_.add_epsilon(epsilon);
  builder_.add_elementwise_affine(elementwise_affine);
  return builder_.Finish();
}

struct LeakyRelu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeakyReluBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVE_SLOPE = 4
  };
  float negative_slope() const {
    return GetField<float>(VT_NEGATIVE_SLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVE_SLOPE) &&
           verifier.EndTable();
  }
};

struct LeakyReluBuilder {
  typedef LeakyRelu Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negative_slope(float negative_slope) {
    fbb_.AddElement<float>(LeakyRelu::VT_NEGATIVE_SLOPE, negative_slope, 0.0f);
  }
  explicit LeakyReluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LeakyRelu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyRelu>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyRelu> CreateLeakyRelu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negative_slope = 0.0f) {
  LeakyReluBuilder builder_(_fbb);
  builder_.add_negative_slope(negative_slope);
  return builder_.Finish();
}

struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessBuilder {
  typedef Less Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline flatbuffers::Offset<Less> CreateLess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LessEqualBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessEqualBuilder {
  typedef LessEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqual> CreateLessEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  typedef Log Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogGradBuilder {
  typedef LogGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogGrad> CreateLogGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalAndBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalAndBuilder {
  typedef LogicalAnd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalAnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalNotBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalNotBuilder {
  typedef LogicalNot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalNot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNot>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogicalOrBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalOrBuilder {
  typedef LogicalOr Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogicalOr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOr>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LpNormalizationBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_P = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t p() const {
    return GetField<int64_t>(VT_P, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_P) &&
           verifier.EndTable();
  }
};

struct LpNormalizationBuilder {
  typedef LpNormalization Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(LpNormalization::VT_AXIS, axis, 0);
  }
  void add_p(int64_t p) {
    fbb_.AddElement<int64_t>(LpNormalization::VT_P, p, 0);
  }
  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LpNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LpNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    int64_t p = 0) {
  LpNormalizationBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct LRN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LRNBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10,
    VT_NORM_REGION = 12
  };
  int64_t depth_radius() const {
    return GetField<int64_t>(VT_DEPTH_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  const flatbuffers::String *norm_region() const {
    return GetPointer<const flatbuffers::String *>(VT_NORM_REGION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_DEPTH_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyOffset(verifier, VT_NORM_REGION) &&
           verifier.VerifyString(norm_region()) &&
           verifier.EndTable();
  }
};

struct LRNBuilder {
  typedef LRN Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth_radius(int64_t depth_radius) {
    fbb_.AddElement<int64_t>(LRN::VT_DEPTH_RADIUS, depth_radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LRN::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LRN::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LRN::VT_BETA, beta, 0.0f);
  }
  void add_norm_region(flatbuffers::Offset<flatbuffers::String> norm_region) {
    fbb_.AddOffset(LRN::VT_NORM_REGION, norm_region);
  }
  explicit LRNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LRN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LRN>(end);
    return o;
  }
};

inline flatbuffers::Offset<LRN> CreateLRN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    flatbuffers::Offset<flatbuffers::String> norm_region = 0) {
  LRNBuilder builder_(_fbb);
  builder_.add_depth_radius(depth_radius);
  builder_.add_norm_region(norm_region);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  return builder_.Finish();
}

inline flatbuffers::Offset<LRN> CreateLRNDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f,
    const char *norm_region = nullptr) {
  auto norm_region__ = norm_region ? _fbb.CreateString(norm_region) : 0;
  return mindspore::schema::CreateLRN(
      _fbb,
      depth_radius,
      bias,
      alpha,
      beta,
      norm_region__);
}

struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LshProjectionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  mindspore::schema::LshProjectionType type() const {
    return static_cast<mindspore::schema::LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LshProjectionBuilder {
  typedef LshProjection Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(mindspore::schema::LshProjectionType type) {
    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LshProjection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LshProjection>(end);
    return o;
  }
};

inline flatbuffers::Offset<LshProjection> CreateLshProjection(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::LshProjectionType type = mindspore::schema::LshProjectionType_UNKNOWN) {
  LshProjectionBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct LSTM FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4,
    VT_HAS_BIAS = 6,
    VT_INPUT_SIZE = 8,
    VT_HIDDEN_SIZE = 10,
    VT_NUM_LAYERS = 12,
    VT_NUM_DIRECTIONS = 14,
    VT_DROPOUT = 16,
    VT_ZONEOUT_CELL = 18,
    VT_ZONEOUT_HIDDEN = 20
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  int64_t hidden_size() const {
    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
  }
  int64_t num_layers() const {
    return GetField<int64_t>(VT_NUM_LAYERS, 0);
  }
  int64_t num_directions() const {
    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
  }
  float dropout() const {
    return GetField<float>(VT_DROPOUT, 0.0f);
  }
  float zoneout_cell() const {
    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
  }
  float zoneout_hidden() const {
    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
           VerifyField<float>(verifier, VT_DROPOUT) &&
           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
           verifier.EndTable();
  }
};

struct LSTMBuilder {
  typedef LSTM Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(LSTM::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(LSTM::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(LSTM::VT_INPUT_SIZE, input_size, 0);
  }
  void add_hidden_size(int64_t hidden_size) {
    fbb_.AddElement<int64_t>(LSTM::VT_HIDDEN_SIZE, hidden_size, 0);
  }
  void add_num_layers(int64_t num_layers) {
    fbb_.AddElement<int64_t>(LSTM::VT_NUM_LAYERS, num_layers, 0);
  }
  void add_num_directions(int64_t num_directions) {
    fbb_.AddElement<int64_t>(LSTM::VT_NUM_DIRECTIONS, num_directions, 0);
  }
  void add_dropout(float dropout) {
    fbb_.AddElement<float>(LSTM::VT_DROPOUT, dropout, 0.0f);
  }
  void add_zoneout_cell(float zoneout_cell) {
    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
  }
  void add_zoneout_hidden(float zoneout_hidden) {
    fbb_.AddElement<float>(LSTM::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
  }
  explicit LSTMBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTM> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTM>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTM> CreateLSTM(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false,
    bool has_bias = false,
    int64_t input_size = 0,
    int64_t hidden_size = 0,
    int64_t num_layers = 0,
    int64_t num_directions = 0,
    float dropout = 0.0f,
    float zoneout_cell = 0.0f,
    float zoneout_hidden = 0.0f) {
  LSTMBuilder builder_(_fbb);
  builder_.add_num_directions(num_directions);
  builder_.add_num_layers(num_layers);
  builder_.add_hidden_size(hidden_size);
  builder_.add_input_size(input_size);
  builder_.add_zoneout_hidden(zoneout_hidden);
  builder_.add_zoneout_cell(zoneout_cell);
  builder_.add_dropout(dropout);
  builder_.add_has_bias(has_bias);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

struct LSTMGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LSTMGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4,
    VT_HAS_BIAS = 6,
    VT_INPUT_SIZE = 8,
    VT_HIDDEN_SIZE = 10,
    VT_NUM_LAYERS = 12,
    VT_NUM_DIRECTIONS = 14,
    VT_DROPOUT = 16,
    VT_ZONEOUT_CELL = 18,
    VT_ZONEOUT_HIDDEN = 20
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  int64_t input_size() const {
    return GetField<int64_t>(VT_INPUT_SIZE, 0);
  }
  int64_t hidden_size() const {
    return GetField<int64_t>(VT_HIDDEN_SIZE, 0);
  }
  int64_t num_layers() const {
    return GetField<int64_t>(VT_NUM_LAYERS, 0);
  }
  int64_t num_directions() const {
    return GetField<int64_t>(VT_NUM_DIRECTIONS, 0);
  }
  float dropout() const {
    return GetField<float>(VT_DROPOUT, 0.0f);
  }
  float zoneout_cell() const {
    return GetField<float>(VT_ZONEOUT_CELL, 0.0f);
  }
  float zoneout_hidden() const {
    return GetField<float>(VT_ZONEOUT_HIDDEN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<int64_t>(verifier, VT_INPUT_SIZE) &&
           VerifyField<int64_t>(verifier, VT_HIDDEN_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NUM_LAYERS) &&
           VerifyField<int64_t>(verifier, VT_NUM_DIRECTIONS) &&
           VerifyField<float>(verifier, VT_DROPOUT) &&
           VerifyField<float>(verifier, VT_ZONEOUT_CELL) &&
           VerifyField<float>(verifier, VT_ZONEOUT_HIDDEN) &&
           verifier.EndTable();
  }
};

struct LSTMGradBuilder {
  typedef LSTMGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(LSTMGrad::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(LSTMGrad::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_input_size(int64_t input_size) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_INPUT_SIZE, input_size, 0);
  }
  void add_hidden_size(int64_t hidden_size) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_HIDDEN_SIZE, hidden_size, 0);
  }
  void add_num_layers(int64_t num_layers) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_LAYERS, num_layers, 0);
  }
  void add_num_directions(int64_t num_directions) {
    fbb_.AddElement<int64_t>(LSTMGrad::VT_NUM_DIRECTIONS, num_directions, 0);
  }
  void add_dropout(float dropout) {
    fbb_.AddElement<float>(LSTMGrad::VT_DROPOUT, dropout, 0.0f);
  }
  void add_zoneout_cell(float zoneout_cell) {
    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_CELL, zoneout_cell, 0.0f);
  }
  void add_zoneout_hidden(float zoneout_hidden) {
    fbb_.AddElement<float>(LSTMGrad::VT_ZONEOUT_HIDDEN, zoneout_hidden, 0.0f);
  }
  explicit LSTMGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LSTMGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMGrad> CreateLSTMGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false,
    bool has_bias = false,
    int64_t input_size = 0,
    int64_t hidden_size = 0,
    int64_t num_layers = 0,
    int64_t num_directions = 0,
    float dropout = 0.0f,
    float zoneout_cell = 0.0f,
    float zoneout_hidden = 0.0f) {
  LSTMGradBuilder builder_(_fbb);
  builder_.add_num_directions(num_directions);
  builder_.add_num_layers(num_layers);
  builder_.add_hidden_size(hidden_size);
  builder_.add_input_size(input_size);
  builder_.add_zoneout_hidden(zoneout_hidden);
  builder_.add_zoneout_cell(zoneout_cell);
  builder_.add_dropout(dropout);
  builder_.add_has_bias(has_bias);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

struct L2NormalizeFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef L2NormalizeFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_ACTIVATION_TYPE = 8
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct L2NormalizeFusionBuilder {
  typedef L2NormalizeFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(L2NormalizeFusion::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(L2NormalizeFusion::VT_EPSILON, epsilon, 0.0f);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(L2NormalizeFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit L2NormalizeFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<L2NormalizeFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormalizeFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0,
    float epsilon = 0.0f,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  L2NormalizeFusionBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<L2NormalizeFusion> CreateL2NormalizeFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr,
    float epsilon = 0.0f,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateL2NormalizeFusion(
      _fbb,
      axis__,
      epsilon,
      activation_type);
}

struct MatMulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MatMulFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TRANSPOSE_A = 4,
    VT_TRANSPOSE_B = 6,
    VT_ACTIVATION_TYPE = 8
  };
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct MatMulFusionBuilder {
  typedef MatMulFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(MatMulFusion::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MatMulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MatMulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MatMulFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMulFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMulFusion> CreateMatMulFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool transpose_a = false,
    bool transpose_b = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MatMulFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  return builder_.Finish();
}

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaximumBuilder {
  typedef Maximum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaximumGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAD_X = 4,
    VT_GRAD_Y = 6
  };
  bool grad_x() const {
    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
  }
  bool grad_y() const {
    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
           verifier.EndTable();
  }
};

struct MaximumGradBuilder {
  typedef MaximumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grad_x(bool grad_x) {
    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
  }
  void add_grad_y(bool grad_y) {
    fbb_.AddElement<uint8_t>(MaximumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
  }
  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaximumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool grad_x = false,
    bool grad_y = false) {
  MaximumGradBuilder builder_(_fbb);
  builder_.add_grad_y(grad_y);
  builder_.add_grad_x(grad_x);
  return builder_.Finish();
}

struct MaxPoolFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxPoolFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD = 8,
    VT_PAD_MODE = 10,
    VT_ROUND_MODE = 12,
    VT_FORMAT = 14,
    VT_GLOBAL = 16,
    VT_ACTIVATION_TYPE = 18
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct MaxPoolFusionBuilder {
  typedef MaxPoolFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(MaxPoolFusion::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(MaxPoolFusion::VT_STRIDES, strides);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(MaxPoolFusion::VT_PAD, pad);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(MaxPoolFusion::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(MaxPoolFusion::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MaxPoolFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MaxPoolFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxPoolFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPoolFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MaxPoolFusionBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_pad(pad);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_activation_type(activation_type);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPoolFusion> CreateMaxPoolFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    bool global = false,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  return mindspore::schema::CreateMaxPoolFusion(
      _fbb,
      kernel_size__,
      strides__,
      pad__,
      pad_mode,
      round_mode,
      format,
      global,
      activation_type);
}

struct MaxPoolGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MaxPoolGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KERNEL_SIZE = 4,
    VT_STRIDES = 6,
    VT_PAD_MODE = 8,
    VT_FORMAT = 10
  };
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *strides() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDES);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDES) &&
           verifier.VerifyVector(strides()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct MaxPoolGradBuilder {
  typedef MaxPoolGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(MaxPoolGrad::VT_KERNEL_SIZE, kernel_size);
  }
  void add_strides(flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides) {
    fbb_.AddOffset(MaxPoolGrad::VT_STRIDES, strides);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(MaxPoolGrad::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(MaxPoolGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit MaxPoolGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MaxPoolGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaxPoolGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> strides = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  MaxPoolGradBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_strides(strides);
  builder_.add_kernel_size(kernel_size);
  builder_.add_pad_mode(pad_mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaxPoolGrad> CreateMaxPoolGradDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *strides = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto strides__ = strides ? _fbb.CreateVector<int64_t>(*strides) : 0;
  return mindspore::schema::CreateMaxPoolGrad(
      _fbb,
      kernel_size__,
      strides__,
      pad_mode,
      format);
}

struct SwitchLayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwitchLayerBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SwitchLayerBuilder {
  typedef SwitchLayer Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwitchLayerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SwitchLayer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SwitchLayer>(end);
    return o;
  }
};

inline flatbuffers::Offset<SwitchLayer> CreateSwitchLayer(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwitchLayerBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MfccBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQ_UPPER_LIMIT = 4,
    VT_FREQ_LOWER_LIMIT = 6,
    VT_FILTER_BANK_CHANNEL_NUM = 8,
    VT_DCT_COEFF_NUM = 10
  };
  float freq_upper_limit() const {
    return GetField<float>(VT_FREQ_UPPER_LIMIT, 0.0f);
  }
  float freq_lower_limit() const {
    return GetField<float>(VT_FREQ_LOWER_LIMIT, 0.0f);
  }
  int64_t filter_bank_channel_num() const {
    return GetField<int64_t>(VT_FILTER_BANK_CHANNEL_NUM, 0);
  }
  int64_t dct_coeff_num() const {
    return GetField<int64_t>(VT_DCT_COEFF_NUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FREQ_UPPER_LIMIT) &&
           VerifyField<float>(verifier, VT_FREQ_LOWER_LIMIT) &&
           VerifyField<int64_t>(verifier, VT_FILTER_BANK_CHANNEL_NUM) &&
           VerifyField<int64_t>(verifier, VT_DCT_COEFF_NUM) &&
           verifier.EndTable();
  }
};

struct MfccBuilder {
  typedef Mfcc Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freq_upper_limit(float freq_upper_limit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQ_UPPER_LIMIT, freq_upper_limit, 0.0f);
  }
  void add_freq_lower_limit(float freq_lower_limit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQ_LOWER_LIMIT, freq_lower_limit, 0.0f);
  }
  void add_filter_bank_channel_num(int64_t filter_bank_channel_num) {
    fbb_.AddElement<int64_t>(Mfcc::VT_FILTER_BANK_CHANNEL_NUM, filter_bank_channel_num, 0);
  }
  void add_dct_coeff_num(int64_t dct_coeff_num) {
    fbb_.AddElement<int64_t>(Mfcc::VT_DCT_COEFF_NUM, dct_coeff_num, 0);
  }
  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mfcc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mfcc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mfcc> CreateMfcc(
    flatbuffers::FlatBufferBuilder &_fbb,
    float freq_upper_limit = 0.0f,
    float freq_lower_limit = 0.0f,
    int64_t filter_bank_channel_num = 0,
    int64_t dct_coeff_num = 0) {
  MfccBuilder builder_(_fbb);
  builder_.add_dct_coeff_num(dct_coeff_num);
  builder_.add_filter_bank_channel_num(filter_bank_channel_num);
  builder_.add_freq_lower_limit(freq_lower_limit);
  builder_.add_freq_upper_limit(freq_upper_limit);
  return builder_.Finish();
}

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinimumBuilder {
  typedef Minimum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MinimumGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAD_X = 4,
    VT_GRAD_Y = 6
  };
  bool grad_x() const {
    return GetField<uint8_t>(VT_GRAD_X, 0) != 0;
  }
  bool grad_y() const {
    return GetField<uint8_t>(VT_GRAD_Y, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_X) &&
           VerifyField<uint8_t>(verifier, VT_GRAD_Y) &&
           verifier.EndTable();
  }
};

struct MinimumGradBuilder {
  typedef MinimumGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_grad_x(bool grad_x) {
    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_X, static_cast<uint8_t>(grad_x), 0);
  }
  void add_grad_y(bool grad_y) {
    fbb_.AddElement<uint8_t>(MinimumGrad::VT_GRAD_Y, static_cast<uint8_t>(grad_y), 0);
  }
  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MinimumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinimumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool grad_x = false,
    bool grad_y = false) {
  MinimumGradBuilder builder_(_fbb);
  builder_.add_grad_y(grad_y);
  builder_.add_grad_x(grad_x);
  return builder_.Finish();
}

struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ModBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ModBuilder {
  typedef Mod Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Mod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mod>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mod> CreateMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ModBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MulFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct MulFusionBuilder {
  typedef MulFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(MulFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit MulFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulFusion> CreateMulFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  MulFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MulGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulGradBuilder {
  typedef MulGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MulGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulGrad> CreateMulGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegBuilder {
  typedef Neg Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NegGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegGradBuilder {
  typedef NegGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NegGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegGrad> CreateNegGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NotEqualBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NotEqualBuilder {
  typedef NotEqual Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqual> CreateNotEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonMaxSuppressionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTER_POINT_BOX = 4
  };
  int64_t center_point_box() const {
    return GetField<int64_t>(VT_CENTER_POINT_BOX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CENTER_POINT_BOX) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionBuilder {
  typedef NonMaxSuppression Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_center_point_box(int64_t center_point_box) {
    fbb_.AddElement<int64_t>(NonMaxSuppression::VT_CENTER_POINT_BOX, center_point_box, 0);
  }
  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonMaxSuppression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t center_point_box = 0) {
  NonMaxSuppressionBuilder builder_(_fbb);
  builder_.add_center_point_box(center_point_box);
  return builder_.Finish();
}

struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OneHotBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct OneHotBuilder {
  typedef OneHot Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(OneHot::VT_AXIS, axis, 0);
  }
  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OneHot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHot>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHot> CreateOneHot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  OneHotBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OnesLikeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnesLikeBuilder {
  typedef OnesLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<OnesLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnesLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnesLike> CreateOnesLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnesLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PadFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PadFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDINGS = 4,
    VT_PADDING_MODE = 6,
    VT_CONSTANT_VALUE = 8
  };
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  mindspore::schema::PaddingMode padding_mode() const {
    return static_cast<mindspore::schema::PaddingMode>(GetField<int8_t>(VT_PADDING_MODE, 0));
  }
  float constant_value() const {
    return GetField<float>(VT_CONSTANT_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           VerifyField<int8_t>(verifier, VT_PADDING_MODE) &&
           VerifyField<float>(verifier, VT_CONSTANT_VALUE) &&
           verifier.EndTable();
  }
};

struct PadFusionBuilder {
  typedef PadFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(PadFusion::VT_PADDINGS, paddings);
  }
  void add_padding_mode(mindspore::schema::PaddingMode padding_mode) {
    fbb_.AddElement<int8_t>(PadFusion::VT_PADDING_MODE, static_cast<int8_t>(padding_mode), 0);
  }
  void add_constant_value(float constant_value) {
    fbb_.AddElement<float>(PadFusion::VT_CONSTANT_VALUE, constant_value, 0.0f);
  }
  explicit PadFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PadFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadFusion> CreatePadFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0,
    mindspore::schema::PaddingMode padding_mode = mindspore::schema::PaddingMode_CONSTANT,
    float constant_value = 0.0f) {
  PadFusionBuilder builder_(_fbb);
  builder_.add_constant_value(constant_value);
  builder_.add_paddings(paddings);
  builder_.add_padding_mode(padding_mode);
  return builder_.Finish();
}

struct PartialFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PartialFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUB_GRAPH_INDEX = 4
  };
  int64_t sub_graph_index() const {
    return GetField<int64_t>(VT_SUB_GRAPH_INDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SUB_GRAPH_INDEX) &&
           verifier.EndTable();
  }
};

struct PartialFusionBuilder {
  typedef PartialFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sub_graph_index(int64_t sub_graph_index) {
    fbb_.AddElement<int64_t>(PartialFusion::VT_SUB_GRAPH_INDEX, sub_graph_index, 0);
  }
  explicit PartialFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PartialFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PartialFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PartialFusion> CreatePartialFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t sub_graph_index = 0) {
  PartialFusionBuilder builder_(_fbb);
  builder_.add_sub_graph_index(sub_graph_index);
  return builder_.Finish();
}

struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowerGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowerGradBuilder {
  typedef PowerGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowerGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowerGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerGradBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct PowFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PowFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_SHIFT = 6
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowFusionBuilder {
  typedef PowFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowFusion::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowFusion::VT_SHIFT, shift, 0.0f);
  }
  explicit PowFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PowFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowFusion> CreatePowFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 1.0f,
    float shift = 0.0f) {
  PowFusionBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  return builder_.Finish();
}

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PriorBoxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_IMAGE_SIZE_W = 12,
    VT_IMAGE_SIZE_H = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_CLIP = 20,
    VT_FLIP = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<int64_t> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<int64_t> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  int64_t image_size_w() const {
    return GetField<int64_t>(VT_IMAGE_SIZE_W, 0);
  }
  int64_t image_size_h() const {
    return GetField<int64_t>(VT_IMAGE_SIZE_H, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 0) != 0;
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 0) != 0;
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_W) &&
           VerifyField<int64_t>(verifier, VT_IMAGE_SIZE_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct PriorBoxBuilder {
  typedef PriorBox Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes) {
    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes) {
    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_image_size_w(int64_t image_size_w) {
    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
  }
  void add_image_size_h(int64_t image_size_h) {
    fbb_.AddElement<int64_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 0);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 0);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    int64_t image_size_w = 0,
    int64_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = false,
    bool flip = false,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_image_size_h(image_size_h);
  builder_.add_image_size_w(image_size_w);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  builder_.add_flip(flip);
  builder_.add_clip(clip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *min_sizes = nullptr,
    const std::vector<int64_t> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    int64_t image_size_w = 0,
    int64_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = false,
    bool flip = false,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int64_t>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int64_t>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return mindspore::schema::CreatePriorBox(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      image_size_w,
      image_size_h,
      step_w,
      step_h,
      clip,
      flip,
      offset);
}

struct PReLUFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PReLUFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNEL_SHARED = 4
  };
  bool channel_shared() const {
    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
           verifier.EndTable();
  }
};

struct PReLUFusionBuilder {
  typedef PReLUFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channel_shared(bool channel_shared) {
    fbb_.AddElement<uint8_t>(PReLUFusion::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
  }
  explicit PReLUFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<PReLUFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReLUFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReLUFusion> CreatePReLUFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channel_shared = false) {
  PReLUFusionBuilder builder_(_fbb);
  builder_.add_channel_shared(channel_shared);
  return builder_.Finish();
}

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RankBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankBuilder {
  typedef Rank Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RangeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_D_TYPE = 4,
    VT_START = 6,
    VT_LIMIT = 8,
    VT_DELTA = 10
  };
  int64_t d_type() const {
    return GetField<int64_t>(VT_D_TYPE, 0);
  }
  int64_t start() const {
    return GetField<int64_t>(VT_START, 0);
  }
  int64_t limit() const {
    return GetField<int64_t>(VT_LIMIT, 0);
  }
  int64_t delta() const {
    return GetField<int64_t>(VT_DELTA, 1LL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_D_TYPE) &&
           VerifyField<int64_t>(verifier, VT_START) &&
           VerifyField<int64_t>(verifier, VT_LIMIT) &&
           VerifyField<int64_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  typedef Range Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_d_type(int64_t d_type) {
    fbb_.AddElement<int64_t>(Range::VT_D_TYPE, d_type, 0);
  }
  void add_start(int64_t start) {
    fbb_.AddElement<int64_t>(Range::VT_START, start, 0);
  }
  void add_limit(int64_t limit) {
    fbb_.AddElement<int64_t>(Range::VT_LIMIT, limit, 0);
  }
  void add_delta(int64_t delta) {
    fbb_.AddElement<int64_t>(Range::VT_DELTA, delta, 1LL);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t d_type = 0,
    int64_t start = 0,
    int64_t limit = 0,
    int64_t delta = 1LL) {
  RangeBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_limit(limit);
  builder_.add_start(start);
  builder_.add_d_type(d_type);
  return builder_.Finish();
}

struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReciprocalBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReciprocalBuilder {
  typedef Reciprocal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reciprocal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reciprocal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReciprocalBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RealDivBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RealDivBuilder {
  typedef RealDiv Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RealDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealDiv> CreateRealDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RealDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReduceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEP_DIMS = 4,
    VT_MODE = 6,
    VT_REDUCE_TO_END = 8,
    VT_COEFF = 10
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  mindspore::schema::ReduceMode mode() const {
    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool reduce_to_end() const {
    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
};

struct ReduceFusionBuilder {
  typedef ReduceFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReduceFusion::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_mode(mindspore::schema::ReduceMode mode) {
    fbb_.AddElement<int8_t>(ReduceFusion::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_reduce_to_end(bool reduce_to_end) {
    fbb_.AddElement<uint8_t>(ReduceFusion::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(ReduceFusion::VT_COEFF, coeff, 0.0f);
  }
  explicit ReduceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceFusion> CreateReduceFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false,
    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  ReduceFusionBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_reduce_to_end(reduce_to_end);
  builder_.add_mode(mode);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReshapeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReshapeBuilder {
  typedef Reshape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReshapeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_METHOD = 6,
    VT_NEW_HEIGHT = 8,
    VT_NEW_WIDTH = 10,
    VT_PRESERVE_ASPECT_RATIO = 12,
    VT_COORDINATE_TRANSFORM_MODE = 14,
    VT_CUBIC_COEFF = 16,
    VT_EXCLUDE_OUTSIDE = 18,
    VT_EXTRAPOLATION_VALUE = 20,
    VT_NEAREST_MODE = 22
  };
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  int64_t new_height() const {
    return GetField<int64_t>(VT_NEW_HEIGHT, 0);
  }
  int64_t new_width() const {
    return GetField<int64_t>(VT_NEW_WIDTH, 0);
  }
  bool preserve_aspect_ratio() const {
    return GetField<uint8_t>(VT_PRESERVE_ASPECT_RATIO, 0) != 0;
  }
  mindspore::schema::CoordinateTransformMode coordinate_transform_mode() const {
    return static_cast<mindspore::schema::CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATE_TRANSFORM_MODE, 0));
  }
  float cubic_coeff() const {
    return GetField<float>(VT_CUBIC_COEFF, 0.0f);
  }
  int64_t exclude_outside() const {
    return GetField<int64_t>(VT_EXCLUDE_OUTSIDE, 0);
  }
  float extrapolation_value() const {
    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
  }
  mindspore::schema::NearestMode nearest_mode() const {
    return static_cast<mindspore::schema::NearestMode>(GetField<int8_t>(VT_NEAREST_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<int64_t>(verifier, VT_NEW_HEIGHT) &&
           VerifyField<int64_t>(verifier, VT_NEW_WIDTH) &&
           VerifyField<uint8_t>(verifier, VT_PRESERVE_ASPECT_RATIO) &&
           VerifyField<int8_t>(verifier, VT_COORDINATE_TRANSFORM_MODE) &&
           VerifyField<float>(verifier, VT_CUBIC_COEFF) &&
           VerifyField<int64_t>(verifier, VT_EXCLUDE_OUTSIDE) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
           VerifyField<int8_t>(verifier, VT_NEAREST_MODE) &&
           verifier.EndTable();
  }
};

struct ResizeBuilder {
  typedef Resize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_new_height(int64_t new_height) {
    fbb_.AddElement<int64_t>(Resize::VT_NEW_HEIGHT, new_height, 0);
  }
  void add_new_width(int64_t new_width) {
    fbb_.AddElement<int64_t>(Resize::VT_NEW_WIDTH, new_width, 0);
  }
  void add_preserve_aspect_ratio(bool preserve_aspect_ratio) {
    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVE_ASPECT_RATIO, static_cast<uint8_t>(preserve_aspect_ratio), 0);
  }
  void add_coordinate_transform_mode(mindspore::schema::CoordinateTransformMode coordinate_transform_mode) {
    fbb_.AddElement<int8_t>(Resize::VT_COORDINATE_TRANSFORM_MODE, static_cast<int8_t>(coordinate_transform_mode), 0);
  }
  void add_cubic_coeff(float cubic_coeff) {
    fbb_.AddElement<float>(Resize::VT_CUBIC_COEFF, cubic_coeff, 0.0f);
  }
  void add_exclude_outside(int64_t exclude_outside) {
    fbb_.AddElement<int64_t>(Resize::VT_EXCLUDE_OUTSIDE, exclude_outside, 0);
  }
  void add_extrapolation_value(float extrapolation_value) {
    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
  }
  void add_nearest_mode(mindspore::schema::NearestMode nearest_mode) {
    fbb_.AddElement<int8_t>(Resize::VT_NEAREST_MODE, static_cast<int8_t>(nearest_mode), 0);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    int64_t new_height = 0,
    int64_t new_width = 0,
    bool preserve_aspect_ratio = false,
    mindspore::schema::CoordinateTransformMode coordinate_transform_mode = mindspore::schema::CoordinateTransformMode_ASYMMETRIC,
    float cubic_coeff = 0.0f,
    int64_t exclude_outside = 0,
    float extrapolation_value = 0.0f,
    mindspore::schema::NearestMode nearest_mode = mindspore::schema::NearestMode_NORMAL) {
  ResizeBuilder builder_(_fbb);
  builder_.add_exclude_outside(exclude_outside);
  builder_.add_new_width(new_width);
  builder_.add_new_height(new_height);
  builder_.add_extrapolation_value(extrapolation_value);
  builder_.add_cubic_coeff(cubic_coeff);
  builder_.add_format(format);
  builder_.add_nearest_mode(nearest_mode);
  builder_.add_coordinate_transform_mode(coordinate_transform_mode);
  builder_.add_preserve_aspect_ratio(preserve_aspect_ratio);
  builder_.add_method(method);
  return builder_.Finish();
}

struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseSequenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int64_t seq_dim() const {
    return GetField<int64_t>(VT_SEQ_DIM, 0);
  }
  int64_t batch_dim() const {
    return GetField<int64_t>(VT_BATCH_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int64_t>(verifier, VT_BATCH_DIM) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceBuilder {
  typedef ReverseSequence Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int64_t seq_dim) {
    fbb_.AddElement<int64_t>(ReverseSequence::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int64_t batch_dim) {
    fbb_.AddElement<int64_t>(ReverseSequence::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seq_dim = 0,
    int64_t batch_dim = 0) {
  ReverseSequenceBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

struct ReverseV2 FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReverseV2Builder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct ReverseV2Builder {
  typedef ReverseV2 Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(ReverseV2::VT_AXIS, axis);
  }
  explicit ReverseV2Builder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReverseV2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2> CreateReverseV2(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  ReverseV2Builder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReverseV2> CreateReverseV2Direct(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateReverseV2(
      _fbb,
      axis__);
}

struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RfftBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FFT_LENGTH = 4
  };
  int64_t fft_length() const {
    return GetField<int64_t>(VT_FFT_LENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_FFT_LENGTH) &&
           verifier.EndTable();
  }
};

struct RfftBuilder {
  typedef Rfft Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fft_length(int64_t fft_length) {
    fbb_.AddElement<int64_t>(Rfft::VT_FFT_LENGTH, fft_length, 0);
  }
  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rfft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft> CreateRfft(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t fft_length = 0) {
  RfftBuilder builder_(_fbb);
  builder_.add_fft_length(fft_length);
  return builder_.Finish();
}

struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ROIPoolingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLED_H = 4,
    VT_POOLED_W = 6,
    VT_SCALE = 8
  };
  int64_t pooled_h() const {
    return GetField<int64_t>(VT_POOLED_H, 0);
  }
  int64_t pooled_w() const {
    return GetField<int64_t>(VT_POOLED_W, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_POOLED_H) &&
           VerifyField<int64_t>(verifier, VT_POOLED_W) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct ROIPoolingBuilder {
  typedef ROIPooling Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooled_h(int64_t pooled_h) {
    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_H, pooled_h, 0);
  }
  void add_pooled_w(int64_t pooled_w) {
    fbb_.AddElement<int64_t>(ROIPooling::VT_POOLED_W, pooled_w, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
  }
  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ROIPooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROIPooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t pooled_h = 0,
    int64_t pooled_w = 0,
    float scale = 0.0f) {
  ROIPoolingBuilder builder_(_fbb);
  builder_.add_pooled_w(pooled_w);
  builder_.add_pooled_h(pooled_h);
  builder_.add_scale(scale);
  return builder_.Finish();
}

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RoundBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RoundBuilder {
  typedef Round Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Round> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Round>(end);
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RsqrtBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RsqrtBuilder {
  typedef Rsqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Rsqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rsqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantDTypeCastBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRC_T = 4,
    VT_DST_T = 6
  };
  int64_t src_t() const {
    return GetField<int64_t>(VT_SRC_T, 0);
  }
  int64_t dst_t() const {
    return GetField<int64_t>(VT_DST_T, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SRC_T) &&
           VerifyField<int64_t>(verifier, VT_DST_T) &&
           verifier.EndTable();
  }
};

struct QuantDTypeCastBuilder {
  typedef QuantDTypeCast Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_src_t(int64_t src_t) {
    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_SRC_T, src_t, 0);
  }
  void add_dst_t(int64_t dst_t) {
    fbb_.AddElement<int64_t>(QuantDTypeCast::VT_DST_T, dst_t, 0);
  }
  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<QuantDTypeCast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t src_t = 0,
    int64_t dst_t = 0) {
  QuantDTypeCastBuilder builder_(_fbb);
  builder_.add_dst_t(dst_t);
  builder_.add_src_t(src_t);
  return builder_.Finish();
}

struct ScaleFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScaleFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ACTIVATION_TYPE = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct ScaleFusionBuilder {
  typedef ScaleFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(ScaleFusion::VT_AXIS, axis, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(ScaleFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit ScaleFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScaleFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScaleFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScaleFusion> CreateScaleFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  ScaleFusionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct ScatterNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterNdBuilder {
  typedef ScatterNd Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNd> CreateScatterNd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SGD FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SGDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NESTEROV = 4,
    VT_DAMPENING = 6,
    VT_WEIGHT_DECAY = 8
  };
  bool nesterov() const {
    return GetField<uint8_t>(VT_NESTEROV, 0) != 0;
  }
  float dampening() const {
    return GetField<float>(VT_DAMPENING, 0.0f);
  }
  float weight_decay() const {
    return GetField<float>(VT_WEIGHT_DECAY, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NESTEROV) &&
           VerifyField<float>(verifier, VT_DAMPENING) &&
           VerifyField<float>(verifier, VT_WEIGHT_DECAY) &&
           verifier.EndTable();
  }
};

struct SGDBuilder {
  typedef SGD Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nesterov(bool nesterov) {
    fbb_.AddElement<uint8_t>(SGD::VT_NESTEROV, static_cast<uint8_t>(nesterov), 0);
  }
  void add_dampening(float dampening) {
    fbb_.AddElement<float>(SGD::VT_DAMPENING, dampening, 0.0f);
  }
  void add_weight_decay(float weight_decay) {
    fbb_.AddElement<float>(SGD::VT_WEIGHT_DECAY, weight_decay, 0.0f);
  }
  explicit SGDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SGD> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SGD>(end);
    return o;
  }
};

inline flatbuffers::Offset<SGD> CreateSGD(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool nesterov = false,
    float dampening = 0.0f,
    float weight_decay = 0.0f) {
  SGDBuilder builder_(_fbb);
  builder_.add_weight_decay(weight_decay);
  builder_.add_dampening(dampening);
  builder_.add_nesterov(nesterov);
  return builder_.Finish();
}

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ShapeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  typedef Shape Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SigmoidCrossEntropyWithLogitsBuilder {
  typedef SigmoidCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SigmoidCrossEntropyWithLogitsGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SigmoidCrossEntropyWithLogitsGradBuilder {
  typedef SigmoidCrossEntropyWithLogitsGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SinBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SinBuilder {
  typedef Sin Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sin> CreateSin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SkipGramBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INCLUDE_ALL_GRAMS = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_NGRAM_SIZE = 8
  };
  bool include_all_grams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_GRAMS, 0) != 0;
  }
  int64_t max_skip_size() const {
    return GetField<int64_t>(VT_MAX_SKIP_SIZE, 0);
  }
  int64_t ngram_size() const {
    return GetField<int64_t>(VT_NGRAM_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_GRAMS) &&
           VerifyField<int64_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<int64_t>(verifier, VT_NGRAM_SIZE) &&
           verifier.EndTable();
  }
};

struct SkipGramBuilder {
  typedef SkipGram Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_include_all_grams(bool include_all_grams) {
    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDE_ALL_GRAMS, static_cast<uint8_t>(include_all_grams), 0);
  }
  void add_max_skip_size(int64_t max_skip_size) {
    fbb_.AddElement<int64_t>(SkipGram::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_ngram_size(int64_t ngram_size) {
    fbb_.AddElement<int64_t>(SkipGram::VT_NGRAM_SIZE, ngram_size, 0);
  }
  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SkipGram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGram>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGram> CreateSkipGram(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool include_all_grams = false,
    int64_t max_skip_size = 0,
    int64_t ngram_size = 0) {
  SkipGramBuilder builder_(_fbb);
  builder_.add_ngram_size(ngram_size);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_include_all_grams(include_all_grams);
  return builder_.Finish();
}

struct SliceFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SliceFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4
  };
  const flatbuffers::Vector<int64_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           verifier.EndTable();
  }
};

struct SliceFusionBuilder {
  typedef SliceFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
    fbb_.AddOffset(SliceFusion::VT_AXES, axes);
  }
  explicit SliceFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SliceFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceFusion> CreateSliceFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0) {
  SliceFusionBuilder builder_(_fbb);
  builder_.add_axes(axes);
  return builder_.Finish();
}

inline flatbuffers::Offset<SliceFusion> CreateSliceFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axes = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
  return mindspore::schema::CreateSliceFusion(
      _fbb,
      axes__);
}

struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SmoothL1LossBuilder {
  typedef SmoothL1Loss Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1Loss> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SmoothL1LossGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SmoothL1LossGradBuilder {
  typedef SmoothL1LossGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct Softmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct SoftmaxBuilder {
  typedef Softmax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Softmax::VT_AXIS, axis);
  }
  explicit SoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Softmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Softmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<Softmax> CreateSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  SoftmaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Softmax> CreateSoftmaxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateSoftmax(
      _fbb,
      axis__);
}

struct SoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SoftmaxCrossEntropyWithLogitsBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SoftmaxCrossEntropyWithLogitsBuilder {
  typedef SoftmaxCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxCrossEntropyWithLogits> CreateSoftmaxCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int64_t> *block_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SIZE);
  }
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SIZE) &&
           verifier.VerifyVector(block_size()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchBuilder {
  typedef SpaceToBatch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCK_SIZE, block_size);
  }
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_size = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_size = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  auto block_size__ = block_size ? _fbb.CreateVector<int64_t>(*block_size) : 0;
  return mindspore::schema::CreateSpaceToBatch(
      _fbb,
      block_size__,
      paddings);
}

struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToBatchNDBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int64_t> *block_shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_BLOCK_SHAPE);
  }
  const mindspore::schema::Vec2D *paddings() const {
    return GetPointer<const mindspore::schema::Vec2D *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCK_SHAPE) &&
           verifier.VerifyVector(block_shape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyTable(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchNDBuilder {
  typedef SpaceToBatchND Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape) {
    fbb_.AddOffset(SpaceToBatchND::VT_BLOCK_SHAPE, block_shape);
  }
  void add_paddings(flatbuffers::Offset<mindspore::schema::Vec2D> paddings) {
    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToBatchND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> block_shape = 0,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  SpaceToBatchNDBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_block_shape(block_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *block_shape = nullptr,
    flatbuffers::Offset<mindspore::schema::Vec2D> paddings = 0) {
  auto block_shape__ = block_shape ? _fbb.CreateVector<int64_t>(*block_shape) : 0;
  return mindspore::schema::CreateSpaceToBatchND(
      _fbb,
      block_shape__,
      paddings);
}

struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpaceToDepthBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCK_SIZE = 4,
    VT_FORMAT = 6
  };
  int64_t block_size() const {
    return GetField<int64_t>(VT_BLOCK_SIZE, 0);
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BLOCK_SIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthBuilder {
  typedef SpaceToDepth Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int64_t block_size) {
    fbb_.AddElement<int64_t>(SpaceToDepth::VT_BLOCK_SIZE, block_size, 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SpaceToDepth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepth>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t block_size = 0,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW) {
  SpaceToDepthBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  builder_.add_format(format);
  return builder_.Finish();
}

struct SparseSoftmaxCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseSoftmaxCrossEntropyWithLogitsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_GRAD = 4
  };
  bool is_grad() const {
    return GetField<uint8_t>(VT_IS_GRAD, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_GRAD) &&
           verifier.EndTable();
  }
};

struct SparseSoftmaxCrossEntropyWithLogitsBuilder {
  typedef SparseSoftmaxCrossEntropyWithLogits Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_grad(bool is_grad) {
    fbb_.AddElement<uint8_t>(SparseSoftmaxCrossEntropyWithLogits::VT_IS_GRAD, static_cast<uint8_t>(is_grad), 0);
  }
  explicit SparseSoftmaxCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseSoftmaxCrossEntropyWithLogits> CreateSparseSoftmaxCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_grad = false) {
  SparseSoftmaxCrossEntropyWithLogitsBuilder builder_(_fbb);
  builder_.add_is_grad(is_grad);
  return builder_.Finish();
}

struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SparseToDenseBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SparseToDenseBuilder {
  typedef SparseToDense Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SparseToDense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDense>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SparseToDenseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_NUM = 4,
    VT_SIZE_SPLITS = 6,
    VT_AXIS = 8
  };
  int64_t output_num() const {
    return GetField<int64_t>(VT_OUTPUT_NUM, 0);
  }
  const flatbuffers::Vector<int64_t> *size_splits() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SIZE_SPLITS);
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_NUM) &&
           VerifyOffset(verifier, VT_SIZE_SPLITS) &&
           verifier.VerifyVector(size_splits()) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SplitBuilder {
  typedef Split Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_num(int64_t output_num) {
    fbb_.AddElement<int64_t>(Split::VT_OUTPUT_NUM, output_num, 0);
  }
  void add_size_splits(flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits) {
    fbb_.AddOffset(Split::VT_SIZE_SPLITS, size_splits);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Split::VT_AXIS, axis, 0);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> size_splits = 0,
    int64_t axis = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_output_num(output_num);
  builder_.add_size_splits(size_splits);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t output_num = 0,
    const std::vector<int64_t> *size_splits = nullptr,
    int64_t axis = 0) {
  auto size_splits__ = size_splits ? _fbb.CreateVector<int64_t>(*size_splits) : 0;
  return mindspore::schema::CreateSplit(
      _fbb,
      output_num,
      size_splits__,
      axis);
}

struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SqrtBuilder {
  typedef Sqrt Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sqrt> CreateSqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqueezeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct SqueezeBuilder {
  typedef Squeeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateSqueeze(
      _fbb,
      axis__);
}

struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquareBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquareBuilder {
  typedef Square Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Square> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Square>(end);
    return o;
  }
};

inline flatbuffers::Offset<Square> CreateSquare(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SquaredDifferenceBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquaredDifferenceBuilder {
  typedef SquaredDifference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SquaredDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct StackBuilder {
  typedef Stack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Stack::VT_AXIS, axis, 0);
  }
  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stack> CreateStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int64_t begin_mask() const {
    return GetField<int64_t>(VT_BEGIN_MASK, 0);
  }
  int64_t end_mask() const {
    return GetField<int64_t>(VT_END_MASK, 0);
  }
  int64_t ellipsis_mask() const {
    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
  }
  int64_t new_axis_mask() const {
    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
  }
  int64_t shrink_axis_mask() const {
    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int64_t>(verifier, VT_END_MASK) &&
           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
};

struct StridedSliceBuilder {
  typedef StridedSlice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int64_t begin_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int64_t end_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int64_t ellipsis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int64_t new_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSlice::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_mask = 0,
    int64_t end_mask = 0,
    int64_t ellipsis_mask = 0,
    int64_t new_axis_mask = 0,
    int64_t shrink_axis_mask = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

struct SubFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           verifier.EndTable();
  }
};

struct SubFusionBuilder {
  typedef SubFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(SubFusion::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  explicit SubFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubFusion> CreateSubFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION) {
  SubFusionBuilder builder_(_fbb);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubGradBuilder {
  typedef SubGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGrad> CreateSubGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SwitchBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SwitchBuilder {
  typedef Switch Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Switch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Switch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Switch> CreateSwitch(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwitchBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListFromTensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4,
    VT_SHAPE_TYPE = 6
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  int64_t shape_type() const {
    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
           verifier.EndTable();
  }
};

struct TensorListFromTensorBuilder {
  typedef TensorListFromTensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  void add_shape_type(int64_t shape_type) {
    fbb_.AddElement<int64_t>(TensorListFromTensor::VT_SHAPE_TYPE, shape_type, 0);
  }
  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListFromTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0,
    int64_t shape_type = 0) {
  TensorListFromTensorBuilder builder_(_fbb);
  builder_.add_shape_type(shape_type);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListGetItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListGetItemBuilder {
  typedef TensorListGetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListGetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0) {
  TensorListGetItemBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListReserveBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4,
    VT_SHAPE_TYPE = 6
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  int64_t shape_type() const {
    return GetField<int64_t>(VT_SHAPE_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           VerifyField<int64_t>(verifier, VT_SHAPE_TYPE) &&
           verifier.EndTable();
  }
};

struct TensorListReserveBuilder {
  typedef TensorListReserve Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListReserve::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  void add_shape_type(int64_t shape_type) {
    fbb_.AddElement<int64_t>(TensorListReserve::VT_SHAPE_TYPE, shape_type, 0);
  }
  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListReserve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListReserve>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0,
    int64_t shape_type = 0) {
  TensorListReserveBuilder builder_(_fbb);
  builder_.add_shape_type(shape_type);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListSetItemBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENT_DTYPE = 4
  };
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListSetItemBuilder {
  typedef TensorListSetItem Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListSetItem::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListSetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListSetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t element_dtype = 0) {
  TensorListSetItemBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  return builder_.Finish();
}

struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorListStackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM_ELEMENTS = 4,
    VT_ELEMENT_DTYPE = 6
  };
  int64_t num_elements() const {
    return GetField<int64_t>(VT_NUM_ELEMENTS, 0);
  }
  int64_t element_dtype() const {
    return GetField<int64_t>(VT_ELEMENT_DTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_NUM_ELEMENTS) &&
           VerifyField<int64_t>(verifier, VT_ELEMENT_DTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListStackBuilder {
  typedef TensorListStack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_elements(int64_t num_elements) {
    fbb_.AddElement<int64_t>(TensorListStack::VT_NUM_ELEMENTS, num_elements, 0);
  }
  void add_element_dtype(int64_t element_dtype) {
    fbb_.AddElement<int64_t>(TensorListStack::VT_ELEMENT_DTYPE, element_dtype, 0);
  }
  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorListStack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListStack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t num_elements = 0,
    int64_t element_dtype = 0) {
  TensorListStackBuilder builder_(_fbb);
  builder_.add_element_dtype(element_dtype);
  builder_.add_num_elements(num_elements);
  return builder_.Finish();
}

struct TileFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TileFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int64_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct TileFusionBuilder {
  typedef TileFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims) {
    fbb_.AddOffset(TileFusion::VT_DIMS, dims);
  }
  explicit TileFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TileFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileFusion> CreateTileFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dims = 0) {
  TileFusionBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileFusion> CreateTileFusionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int64_t>(*dims) : 0;
  return mindspore::schema::CreateTileFusion(
      _fbb,
      dims__);
}

struct TopKFusion FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TopKFusionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SORTED = 4,
    VT_AXIS = 6,
    VT_LARGEST = 8
  };
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  int64_t largest() const {
    return GetField<int64_t>(VT_LARGEST, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<int64_t>(verifier, VT_LARGEST) &&
           verifier.EndTable();
  }
};

struct TopKFusionBuilder {
  typedef TopKFusion Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopKFusion::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(TopKFusion::VT_AXIS, axis, 0);
  }
  void add_largest(int64_t largest) {
    fbb_.AddElement<int64_t>(TopKFusion::VT_LARGEST, largest, 0);
  }
  explicit TopKFusionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TopKFusion> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKFusion>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKFusion> CreateTopKFusion(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool sorted = true,
    int64_t axis = 0,
    int64_t largest = 0) {
  TopKFusionBuilder builder_(_fbb);
  builder_.add_largest(largest);
  builder_.add_axis(axis);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TransposeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TransposeBuilder {
  typedef Transpose Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniqueBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UniqueBuilder {
  typedef Unique Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unique> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unique>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unique> CreateUnique(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UniqueBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsortedSegmentSumBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct UnsortedSegmentSumBuilder {
  typedef UnsortedSegmentSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  UnsortedSegmentSumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnsqueezeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int64_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct UnsqueezeBuilder {
  typedef Unsqueeze Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis) {
    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
  }
  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unsqueeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsqueeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axis = 0) {
  UnsqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int64_t>(*axis) : 0;
  return mindspore::schema::CreateUnsqueeze(
      _fbb,
      axis__);
}

struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UnstackBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct UnstackBuilder {
  typedef Unstack Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Unstack::VT_AXIS, axis, 0);
  }
  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unstack> CreateUnstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef WhereBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WhereBuilder {
  typedef Where Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline flatbuffers::Offset<Where> CreateWhere(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ZerosLikeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ZerosLikeBuilder {
  typedef ZerosLike Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ZerosLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SelectBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectBuilder {
  typedef Select Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Select> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Select>(end);
    return o;
  }
};

inline flatbuffers::Offset<Select> CreateSelect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GRU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GRUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTIONAL = 4
  };
  bool bidirectional() const {
    return GetField<uint8_t>(VT_BIDIRECTIONAL, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTIONAL) &&
           verifier.EndTable();
  }
};

struct GRUBuilder {
  typedef GRU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirectional(bool bidirectional) {
    fbb_.AddElement<uint8_t>(GRU::VT_BIDIRECTIONAL, static_cast<uint8_t>(bidirectional), 0);
  }
  explicit GRUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GRU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GRU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GRU> CreateGRU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirectional = false) {
  GRUBuilder builder_(_fbb);
  builder_.add_bidirectional(bidirectional);
  return builder_.Finish();
}

struct NonZero FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef NonZeroBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NonZeroBuilder {
  typedef NonZero Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NonZeroBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<NonZero> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonZero>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonZero> CreateNonZero(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NonZeroBuilder builder_(_fbb);
  return builder_.Finish();
}

struct InvertPermutation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InvertPermutationBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct InvertPermutationBuilder {
  typedef InvertPermutation Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit InvertPermutationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InvertPermutation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InvertPermutation>(end);
    return o;
  }
};

inline flatbuffers::Offset<InvertPermutation> CreateInvertPermutation(
    flatbuffers::FlatBufferBuilder &_fbb) {
  InvertPermutationBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Size FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SizeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SizeBuilder {
  typedef Size Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Size> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Size>(end);
    return o;
  }
};

inline flatbuffers::Offset<Size> CreateSize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RandomStandardNormal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RandomStandardNormalBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) &&
           verifier.EndTable();
  }
};

struct RandomStandardNormalBuilder {
  typedef RandomStandardNormal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(RandomStandardNormal::VT_SEED2, seed2, 0);
  }
  explicit RandomStandardNormalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RandomStandardNormal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RandomStandardNormal>(end);
    return o;
  }
};

inline flatbuffers::Offset<RandomStandardNormal> CreateRandomStandardNormal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  RandomStandardNormalBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct CropAndResize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CropAndResizeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_EXTRAPOLATION_VALUE = 6
  };
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  float extrapolation_value() const {
    return GetField<float>(VT_EXTRAPOLATION_VALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATION_VALUE) &&
           verifier.EndTable();
  }
};

struct CropAndResizeBuilder {
  typedef CropAndResize Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(CropAndResize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_extrapolation_value(float extrapolation_value) {
    fbb_.AddElement<float>(CropAndResize::VT_EXTRAPOLATION_VALUE, extrapolation_value, 0.0f);
  }
  explicit CropAndResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CropAndResize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CropAndResize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CropAndResize> CreateCropAndResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    float extrapolation_value = 0.0f) {
  CropAndResizeBuilder builder_(_fbb);
  builder_.add_extrapolation_value(extrapolation_value);
  builder_.add_method(method);
  return builder_.Finish();
}

struct Erf FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErfBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ErfBuilder {
  typedef Erf Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ErfBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Erf> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Erf>(end);
    return o;
  }
};

inline flatbuffers::Offset<Erf> CreateErf(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ErfBuilder builder_(_fbb);
  return builder_.Finish();
}

struct StridedSliceGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StridedSliceGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int64_t begin_mask() const {
    return GetField<int64_t>(VT_BEGIN_MASK, 0);
  }
  int64_t end_mask() const {
    return GetField<int64_t>(VT_END_MASK, 0);
  }
  int64_t ellipsis_mask() const {
    return GetField<int64_t>(VT_ELLIPSIS_MASK, 0);
  }
  int64_t new_axis_mask() const {
    return GetField<int64_t>(VT_NEW_AXIS_MASK, 0);
  }
  int64_t shrink_axis_mask() const {
    return GetField<int64_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int64_t>(verifier, VT_END_MASK) &&
           VerifyField<int64_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int64_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
};

struct StridedSliceGradBuilder {
  typedef StridedSliceGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int64_t begin_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int64_t end_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int64_t ellipsis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int64_t new_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int64_t shrink_axis_mask) {
    fbb_.AddElement<int64_t>(StridedSliceGrad::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StridedSliceGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceGrad> CreateStridedSliceGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_mask = 0,
    int64_t end_mask = 0,
    int64_t ellipsis_mask = 0,
    int64_t new_axis_mask = 0,
    int64_t shrink_axis_mask = 0) {
  StridedSliceGradBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

struct IsFinite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IsFiniteBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IsFiniteBuilder {
  typedef IsFinite Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IsFiniteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IsFinite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IsFinite>(end);
    return o;
  }
};

inline flatbuffers::Offset<IsFinite> CreateIsFinite(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IsFiniteBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LinSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LinSpaceBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LinSpaceBuilder {
  typedef LinSpace Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LinSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LinSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LinSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<LinSpace> CreateLinSpace(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LinSpaceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UniformReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UniformRealBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEED = 4,
    VT_SEED2 = 6
  };
  int64_t seed() const {
    return GetField<int64_t>(VT_SEED, 0);
  }
  int64_t seed2() const {
    return GetField<int64_t>(VT_SEED2, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SEED) &&
           VerifyField<int64_t>(verifier, VT_SEED2) &&
           verifier.EndTable();
  }
};

struct UniformRealBuilder {
  typedef UniformReal Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seed(int64_t seed) {
    fbb_.AddElement<int64_t>(UniformReal::VT_SEED, seed, 0);
  }
  void add_seed2(int64_t seed2) {
    fbb_.AddElement<int64_t>(UniformReal::VT_SEED2, seed2, 0);
  }
  explicit UniformRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<UniformReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniformReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniformReal> CreateUniformReal(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t seed = 0,
    int64_t seed2 = 0) {
  UniformRealBuilder builder_(_fbb);
  builder_.add_seed2(seed2);
  builder_.add_seed(seed);
  return builder_.Finish();
}

struct AbsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AbsGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsGradBuilder {
  typedef AbsGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AbsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsGrad> CreateAbsGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RsqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RsqrtGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RsqrtGradBuilder {
  typedef RsqrtGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RsqrtGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RsqrtGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<RsqrtGrad> CreateRsqrtGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SqrtGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SqrtGradBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SqrtGradBuilder {
  typedef SqrtGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SqrtGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqrtGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqrtGrad> CreateSqrtGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LayerNormGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LayerNormGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGIN_NORM_AXIS = 4,
    VT_BEGIN_PARAMS_AXIS = 6
  };
  int64_t begin_norm_axis() const {
    return GetField<int64_t>(VT_BEGIN_NORM_AXIS, 0);
  }
  int64_t begin_params_axis() const {
    return GetField<int64_t>(VT_BEGIN_PARAMS_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_NORM_AXIS) &&
           VerifyField<int64_t>(verifier, VT_BEGIN_PARAMS_AXIS) &&
           verifier.EndTable();
  }
};

struct LayerNormGradBuilder {
  typedef LayerNormGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_norm_axis(int64_t begin_norm_axis) {
    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_NORM_AXIS, begin_norm_axis, 0);
  }
  void add_begin_params_axis(int64_t begin_params_axis) {
    fbb_.AddElement<int64_t>(LayerNormGrad::VT_BEGIN_PARAMS_AXIS, begin_params_axis, 0);
  }
  explicit LayerNormGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LayerNormGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNormGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNormGrad> CreateLayerNormGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t begin_norm_axis = 0,
    int64_t begin_params_axis = 0) {
  LayerNormGradBuilder builder_(_fbb);
  builder_.add_begin_params_axis(begin_params_axis);
  builder_.add_begin_norm_axis(begin_norm_axis);
  return builder_.Finish();
}

struct ResizeGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ResizeGradBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_METHOD = 4,
    VT_ALIGN_CORNERS = 6
  };
  mindspore::schema::ResizeMethod method() const {
    return static_cast<mindspore::schema::ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
};

struct ResizeGradBuilder {
  typedef ResizeGrad Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_method(mindspore::schema::ResizeMethod method) {
    fbb_.AddElement<int8_t>(ResizeGrad::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeGrad::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ResizeGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeGrad> CreateResizeGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ResizeMethod method = mindspore::schema::ResizeMethod_LINEAR,
    bool align_corners = false) {
  ResizeGradBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  builder_.add_method(method);
  return builder_.Finish();
}

struct Splice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SpliceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_FORWARD_INDEXES = 6,
    VT_OUTPUT_DIM = 8
  };
  const flatbuffers::Vector<int64_t> *context() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  const flatbuffers::Vector<int64_t> *forward_indexes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_FORWARD_INDEXES);
  }
  int64_t output_dim() const {
    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyVector(context()) &&
           VerifyOffset(verifier, VT_FORWARD_INDEXES) &&
           verifier.VerifyVector(forward_indexes()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
           verifier.EndTable();
  }
};

struct SpliceBuilder {
  typedef Splice Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
    fbb_.AddOffset(Splice::VT_CONTEXT, context);
  }
  void add_forward_indexes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes) {
    fbb_.AddOffset(Splice::VT_FORWARD_INDEXES, forward_indexes);
  }
  void add_output_dim(int64_t output_dim) {
    fbb_.AddElement<int64_t>(Splice::VT_OUTPUT_DIM, output_dim, 0);
  }
  explicit SpliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Splice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Splice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Splice> CreateSplice(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> forward_indexes = 0,
    int64_t output_dim = 0) {
  SpliceBuilder builder_(_fbb);
  builder_.add_output_dim(output_dim);
  builder_.add_forward_indexes(forward_indexes);
  builder_.add_context(context);
  return builder_.Finish();
}

inline flatbuffers::Offset<Splice> CreateSpliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *context = nullptr,
    const std::vector<int64_t> *forward_indexes = nullptr,
    int64_t output_dim = 0) {
  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
  auto forward_indexes__ = forward_indexes ? _fbb.CreateVector<int64_t>(*forward_indexes) : 0;
  return mindspore::schema::CreateSplice(
      _fbb,
      context__,
      forward_indexes__,
      output_dim);
}

struct LogSoftmax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LogSoftmaxBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct LogSoftmaxBuilder {
  typedef LogSoftmax Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(LogSoftmax::VT_AXIS, axis, 0);
  }
  explicit LogSoftmaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LogSoftmax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmax>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmax> CreateLogSoftmax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0) {
  LogSoftmaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Call FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CallBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_IS_TAIL_CALL = 4
  };
  bool is_tail_call() const {
    return GetField<uint8_t>(VT_IS_TAIL_CALL, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_IS_TAIL_CALL) &&
           verifier.EndTable();
  }
};

struct CallBuilder {
  typedef Call Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_is_tail_call(bool is_tail_call) {
    fbb_.AddElement<uint8_t>(Call::VT_IS_TAIL_CALL, static_cast<uint8_t>(is_tail_call), 1);
  }
  explicit CallBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Call> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Call>(end);
    return o;
  }
};

inline flatbuffers::Offset<Call> CreateCall(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool is_tail_call = true) {
  CallBuilder builder_(_fbb);
  builder_.add_is_tail_call(is_tail_call);
  return builder_.Finish();
}

struct CumSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CumSumBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXCLUSIVE = 4,
    VT_REVERSE = 6
  };
  bool exclusive() const {
    return GetField<uint8_t>(VT_EXCLUSIVE, 0) != 0;
  }
  bool reverse() const {
    return GetField<uint8_t>(VT_REVERSE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EXCLUSIVE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
};

struct CumSumBuilder {
  typedef CumSum Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_exclusive(bool exclusive) {
    fbb_.AddElement<uint8_t>(CumSum::VT_EXCLUSIVE, static_cast<uint8_t>(exclusive), 0);
  }
  void add_reverse(bool reverse) {
    fbb_.AddElement<uint8_t>(CumSum::VT_REVERSE, static_cast<uint8_t>(reverse), 0);
  }
  explicit CumSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CumSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CumSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<CumSum> CreateCumSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool exclusive = false,
    bool reverse = false) {
  CumSumBuilder builder_(_fbb);
  builder_.add_reverse(reverse);
  builder_.add_exclusive(exclusive);
  return builder_.Finish();
}

struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CustomBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ATTR = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
};

struct CustomBuilder {
  typedef Custom Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Custom::VT_TYPE, type);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr) {
    fbb_.AddOffset(Custom::VT_ATTR, attr);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Attribute>>> attr = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Custom> CreateCustomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const std::vector<flatbuffers::Offset<mindspore::schema::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto attr__ = attr ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Attribute>>(*attr) : 0;
  return mindspore::schema::CreateCustom(
      _fbb,
      type__,
      attr__);
}

struct SplitWithOverlap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SplitWithOverlapBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPLIT_DIM = 4,
    VT_NUMBER_SPLIT = 6,
    VT_RATIO = 8,
    VT_EXTEND_TOP = 10,
    VT_EXTEND_BOTTOM = 12
  };
  int64_t split_dim() const {
    return GetField<int64_t>(VT_SPLIT_DIM, 0);
  }
  int64_t number_split() const {
    return GetField<int64_t>(VT_NUMBER_SPLIT, 0);
  }
  const flatbuffers::Vector<int64_t> *ratio() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_RATIO);
  }
  const flatbuffers::Vector<int64_t> *extend_top() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_TOP);
  }
  const flatbuffers::Vector<int64_t> *extend_bottom() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_EXTEND_BOTTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_SPLIT_DIM) &&
           VerifyField<int64_t>(verifier, VT_NUMBER_SPLIT) &&
           VerifyOffset(verifier, VT_RATIO) &&
           verifier.VerifyVector(ratio()) &&
           VerifyOffset(verifier, VT_EXTEND_TOP) &&
           verifier.VerifyVector(extend_top()) &&
           VerifyOffset(verifier, VT_EXTEND_BOTTOM) &&
           verifier.VerifyVector(extend_bottom()) &&
           verifier.EndTable();
  }
};

struct SplitWithOverlapBuilder {
  typedef SplitWithOverlap Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_split_dim(int64_t split_dim) {
    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_SPLIT_DIM, split_dim, 0);
  }
  void add_number_split(int64_t number_split) {
    fbb_.AddElement<int64_t>(SplitWithOverlap::VT_NUMBER_SPLIT, number_split, 0);
  }
  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio) {
    fbb_.AddOffset(SplitWithOverlap::VT_RATIO, ratio);
  }
  void add_extend_top(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top) {
    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_TOP, extend_top);
  }
  void add_extend_bottom(flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom) {
    fbb_.AddOffset(SplitWithOverlap::VT_EXTEND_BOTTOM, extend_bottom);
  }
  explicit SplitWithOverlapBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SplitWithOverlap> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitWithOverlap>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlap(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t split_dim = 0,
    int64_t number_split = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> ratio = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_top = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> extend_bottom = 0) {
  SplitWithOverlapBuilder builder_(_fbb);
  builder_.add_number_split(number_split);
  builder_.add_split_dim(split_dim);
  builder_.add_extend_bottom(extend_bottom);
  builder_.add_extend_top(extend_top);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

inline flatbuffers::Offset<SplitWithOverlap> CreateSplitWithOverlapDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t split_dim = 0,
    int64_t number_split = 0,
    const std::vector<int64_t> *ratio = nullptr,
    const std::vector<int64_t> *extend_top = nullptr,
    const std::vector<int64_t> *extend_bottom = nullptr) {
  auto ratio__ = ratio ? _fbb.CreateVector<int64_t>(*ratio) : 0;
  auto extend_top__ = extend_top ? _fbb.CreateVector<int64_t>(*extend_top) : 0;
  auto extend_bottom__ = extend_bottom ? _fbb.CreateVector<int64_t>(*extend_bottom) : 0;
  return mindspore::schema::CreateSplitWithOverlap(
      _fbb,
      split_dim,
      number_split,
      ratio__,
      extend_top__,
      extend_bottom__);
}

struct GenOP FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GenOPBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATION_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10,
    VT_IS_TRAINING = 12,
    VT_FORMAT = 14,
    VT_KERNEL_SIZE = 16,
    VT_STRIDE = 18,
    VT_DILATION = 20,
    VT_PAD_MODE = 22,
    VT_PAD_LIST = 24,
    VT_MODE = 26,
    VT_GROUP = 28,
    VT_IN_CHANNEL = 30,
    VT_OUT_CHANNEL = 32,
    VT_ELTWISE_MODE = 34,
    VT_HAS_BIAS = 36,
    VT_USE_AXIS = 38,
    VT_AXIS = 40,
    VT_EPSILON = 42,
    VT_MOMENTUM = 44,
    VT_TRANSPOSE_A = 46,
    VT_TRANSPOSE_B = 48,
    VT_PAD = 50,
    VT_ROUND_MODE = 52,
    VT_GLOBAL = 54,
    VT_CHANNEL_SHARED = 56,
    VT_AXES = 58,
    VT_KEEP_DIMS = 60,
    VT_REDUCE_MODE = 62,
    VT_REDUCE_TO_END = 64,
    VT_COEFF = 66
  };
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, 0.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 0.0f);
  }
  bool is_training() const {
    return GetField<uint8_t>(VT_IS_TRAINING, 0) != 0;
  }
  mindspore::schema::Format format() const {
    return static_cast<mindspore::schema::Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *kernel_size() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_KERNEL_SIZE);
  }
  const flatbuffers::Vector<int64_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int64_t> *dilation() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DILATION);
  }
  mindspore::schema::PadMode pad_mode() const {
    return static_cast<mindspore::schema::PadMode>(GetField<int8_t>(VT_PAD_MODE, 0));
  }
  const flatbuffers::Vector<int64_t> *pad_list() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD_LIST);
  }
  int64_t mode() const {
    return GetField<int64_t>(VT_MODE, 0);
  }
  int64_t group() const {
    return GetField<int64_t>(VT_GROUP, 0);
  }
  int64_t in_channel() const {
    return GetField<int64_t>(VT_IN_CHANNEL, 0);
  }
  int64_t out_channel() const {
    return GetField<int64_t>(VT_OUT_CHANNEL, 0);
  }
  mindspore::schema::EltwiseMode eltwise_mode() const {
    return static_cast<mindspore::schema::EltwiseMode>(GetField<int8_t>(VT_ELTWISE_MODE, 0));
  }
  bool has_bias() const {
    return GetField<uint8_t>(VT_HAS_BIAS, 0) != 0;
  }
  bool use_axis() const {
    return GetField<uint8_t>(VT_USE_AXIS, 0) != 0;
  }
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  const flatbuffers::Vector<int64_t> *pad() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_PAD);
  }
  mindspore::schema::RoundMode round_mode() const {
    return static_cast<mindspore::schema::RoundMode>(GetField<int8_t>(VT_ROUND_MODE, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  bool channel_shared() const {
    return GetField<uint8_t>(VT_CHANNEL_SHARED, 0) != 0;
  }
  const flatbuffers::Vector<int64_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_AXES);
  }
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  mindspore::schema::ReduceMode reduce_mode() const {
    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_REDUCE_MODE, 0));
  }
  bool reduce_to_end() const {
    return GetField<uint8_t>(VT_REDUCE_TO_END, 0) != 0;
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           VerifyField<uint8_t>(verifier, VT_IS_TRAINING) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_KERNEL_SIZE) &&
           verifier.VerifyVector(kernel_size()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_DILATION) &&
           verifier.VerifyVector(dilation()) &&
           VerifyField<int8_t>(verifier, VT_PAD_MODE) &&
           VerifyOffset(verifier, VT_PAD_LIST) &&
           verifier.VerifyVector(pad_list()) &&
           VerifyField<int64_t>(verifier, VT_MODE) &&
           VerifyField<int64_t>(verifier, VT_GROUP) &&
           VerifyField<int64_t>(verifier, VT_IN_CHANNEL) &&
           VerifyField<int64_t>(verifier, VT_OUT_CHANNEL) &&
           VerifyField<int8_t>(verifier, VT_ELTWISE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_HAS_BIAS) &&
           VerifyField<uint8_t>(verifier, VT_USE_AXIS) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           VerifyOffset(verifier, VT_PAD) &&
           verifier.VerifyVector(pad()) &&
           VerifyField<int8_t>(verifier, VT_ROUND_MODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL_SHARED) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           VerifyField<int8_t>(verifier, VT_REDUCE_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCE_TO_END) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
};

struct GenOPBuilder {
  typedef GenOP Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(GenOP::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(GenOP::VT_ALPHA, alpha, 0.0f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(GenOP::VT_MIN_VAL, min_val, 0.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(GenOP::VT_MAX_VAL, max_val, 0.0f);
  }
  void add_is_training(bool is_training) {
    fbb_.AddElement<uint8_t>(GenOP::VT_IS_TRAINING, static_cast<uint8_t>(is_training), 0);
  }
  void add_format(mindspore::schema::Format format) {
    fbb_.AddElement<int32_t>(GenOP::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_kernel_size(flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size) {
    fbb_.AddOffset(GenOP::VT_KERNEL_SIZE, kernel_size);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride) {
    fbb_.AddOffset(GenOP::VT_STRIDE, stride);
  }
  void add_dilation(flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation) {
    fbb_.AddOffset(GenOP::VT_DILATION, dilation);
  }
  void add_pad_mode(mindspore::schema::PadMode pad_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_PAD_MODE, static_cast<int8_t>(pad_mode), 0);
  }
  void add_pad_list(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list) {
    fbb_.AddOffset(GenOP::VT_PAD_LIST, pad_list);
  }
  void add_mode(int64_t mode) {
    fbb_.AddElement<int64_t>(GenOP::VT_MODE, mode, 0);
  }
  void add_group(int64_t group) {
    fbb_.AddElement<int64_t>(GenOP::VT_GROUP, group, 0);
  }
  void add_in_channel(int64_t in_channel) {
    fbb_.AddElement<int64_t>(GenOP::VT_IN_CHANNEL, in_channel, 0);
  }
  void add_out_channel(int64_t out_channel) {
    fbb_.AddElement<int64_t>(GenOP::VT_OUT_CHANNEL, out_channel, 0);
  }
  void add_eltwise_mode(mindspore::schema::EltwiseMode eltwise_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_ELTWISE_MODE, static_cast<int8_t>(eltwise_mode), 0);
  }
  void add_has_bias(bool has_bias) {
    fbb_.AddElement<uint8_t>(GenOP::VT_HAS_BIAS, static_cast<uint8_t>(has_bias), 0);
  }
  void add_use_axis(bool use_axis) {
    fbb_.AddElement<uint8_t>(GenOP::VT_USE_AXIS, static_cast<uint8_t>(use_axis), 0);
  }
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(GenOP::VT_AXIS, axis, 0);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(GenOP::VT_EPSILON, epsilon, 0.0001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(GenOP::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(GenOP::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  void add_pad(flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad) {
    fbb_.AddOffset(GenOP::VT_PAD, pad);
  }
  void add_round_mode(mindspore::schema::RoundMode round_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_ROUND_MODE, static_cast<int8_t>(round_mode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(GenOP::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_channel_shared(bool channel_shared) {
    fbb_.AddElement<uint8_t>(GenOP::VT_CHANNEL_SHARED, static_cast<uint8_t>(channel_shared), 0);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes) {
    fbb_.AddOffset(GenOP::VT_AXES, axes);
  }
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(GenOP::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  void add_reduce_mode(mindspore::schema::ReduceMode reduce_mode) {
    fbb_.AddElement<int8_t>(GenOP::VT_REDUCE_MODE, static_cast<int8_t>(reduce_mode), 0);
  }
  void add_reduce_to_end(bool reduce_to_end) {
    fbb_.AddElement<uint8_t>(GenOP::VT_REDUCE_TO_END, static_cast<uint8_t>(reduce_to_end), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(GenOP::VT_COEFF, coeff, 0.0f);
  }
  explicit GenOPBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GenOP> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GenOP>(end);
    return o;
  }
};

inline flatbuffers::Offset<GenOP> CreateGenOP(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool is_training = false,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> kernel_size = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> dilation = 0,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad_list = 0,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    bool transpose_a = false,
    bool transpose_b = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> pad = 0,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    bool global = false,
    bool channel_shared = false,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> axes = 0,
    bool keep_dims = false,
    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  GenOPBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_out_channel(out_channel);
  builder_.add_in_channel(in_channel);
  builder_.add_group(group);
  builder_.add_mode(mode);
  builder_.add_coeff(coeff);
  builder_.add_axes(axes);
  builder_.add_pad(pad);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  builder_.add_pad_list(pad_list);
  builder_.add_dilation(dilation);
  builder_.add_stride(stride);
  builder_.add_kernel_size(kernel_size);
  builder_.add_format(format);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_reduce_to_end(reduce_to_end);
  builder_.add_reduce_mode(reduce_mode);
  builder_.add_keep_dims(keep_dims);
  builder_.add_channel_shared(channel_shared);
  builder_.add_global(global);
  builder_.add_round_mode(round_mode);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  builder_.add_use_axis(use_axis);
  builder_.add_has_bias(has_bias);
  builder_.add_eltwise_mode(eltwise_mode);
  builder_.add_pad_mode(pad_mode);
  builder_.add_is_training(is_training);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<GenOP> CreateGenOPDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    float alpha = 0.0f,
    float min_val = 0.0f,
    float max_val = 0.0f,
    bool is_training = false,
    mindspore::schema::Format format = mindspore::schema::Format_NCHW,
    const std::vector<int64_t> *kernel_size = nullptr,
    const std::vector<int64_t> *stride = nullptr,
    const std::vector<int64_t> *dilation = nullptr,
    mindspore::schema::PadMode pad_mode = mindspore::schema::PadMode_PAD,
    const std::vector<int64_t> *pad_list = nullptr,
    int64_t mode = 0,
    int64_t group = 0,
    int64_t in_channel = 0,
    int64_t out_channel = 0,
    mindspore::schema::EltwiseMode eltwise_mode = mindspore::schema::EltwiseMode_PROD,
    bool has_bias = false,
    bool use_axis = false,
    int64_t axis = 0,
    float epsilon = 0.0001f,
    float momentum = 0.9f,
    bool transpose_a = false,
    bool transpose_b = false,
    const std::vector<int64_t> *pad = nullptr,
    mindspore::schema::RoundMode round_mode = mindspore::schema::RoundMode_FLOOR,
    bool global = false,
    bool channel_shared = false,
    const std::vector<int64_t> *axes = nullptr,
    bool keep_dims = false,
    mindspore::schema::ReduceMode reduce_mode = mindspore::schema::ReduceMode_ReduceMean,
    bool reduce_to_end = false,
    float coeff = 0.0f) {
  auto kernel_size__ = kernel_size ? _fbb.CreateVector<int64_t>(*kernel_size) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int64_t>(*stride) : 0;
  auto dilation__ = dilation ? _fbb.CreateVector<int64_t>(*dilation) : 0;
  auto pad_list__ = pad_list ? _fbb.CreateVector<int64_t>(*pad_list) : 0;
  auto pad__ = pad ? _fbb.CreateVector<int64_t>(*pad) : 0;
  auto axes__ = axes ? _fbb.CreateVector<int64_t>(*axes) : 0;
  return mindspore::schema::CreateGenOP(
      _fbb,
      activation_type,
      alpha,
      min_val,
      max_val,
      is_training,
      format,
      kernel_size__,
      stride__,
      dilation__,
      pad_mode,
      pad_list__,
      mode,
      group,
      in_channel,
      out_channel,
      eltwise_mode,
      has_bias,
      use_axis,
      axis,
      epsilon,
      momentum,
      transpose_a,
      transpose_b,
      pad__,
      round_mode,
      global,
      channel_shared,
      axes__,
      keep_dims,
      reduce_mode,
      reduce_to_end,
      coeff);
}

struct RaggedRange FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RaggedRangeBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RaggedRangeBuilder {
  typedef RaggedRange Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RaggedRangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RaggedRange> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RaggedRange>(end);
    return o;
  }
};

inline flatbuffers::Offset<RaggedRange> CreateRaggedRange(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RaggedRangeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GLUBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, -1LL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct GLUBuilder {
  typedef GLU Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(GLU::VT_AXIS, axis, -1LL);
  }
  explicit GLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<GLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GLU> CreateGLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = -1LL) {
  GLUBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TensorArray FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DYNAMIC_SIZE = 4,
    VT_IDENTICAL_ELEMENT_SHAPES = 6,
    VT_ELEMENT_SHAPE = 8,
    VT_DATA_TYPE = 10
  };
  bool dynamic_size() const {
    return GetField<uint8_t>(VT_DYNAMIC_SIZE, 0) != 0;
  }
  bool identical_element_shapes() const {
    return GetField<uint8_t>(VT_IDENTICAL_ELEMENT_SHAPES, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *element_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ELEMENT_SHAPE);
  }
  int32_t data_type() const {
    return GetField<int32_t>(VT_DATA_TYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_DYNAMIC_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_IDENTICAL_ELEMENT_SHAPES) &&
           VerifyOffset(verifier, VT_ELEMENT_SHAPE) &&
           verifier.VerifyVector(element_shape()) &&
           VerifyField<int32_t>(verifier, VT_DATA_TYPE) &&
           verifier.EndTable();
  }
};

struct TensorArrayBuilder {
  typedef TensorArray Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dynamic_size(bool dynamic_size) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_DYNAMIC_SIZE, static_cast<uint8_t>(dynamic_size), 0);
  }
  void add_identical_element_shapes(bool identical_element_shapes) {
    fbb_.AddElement<uint8_t>(TensorArray::VT_IDENTICAL_ELEMENT_SHAPES, static_cast<uint8_t>(identical_element_shapes), 0);
  }
  void add_element_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape) {
    fbb_.AddOffset(TensorArray::VT_ELEMENT_SHAPE, element_shape);
  }
  void add_data_type(int32_t data_type) {
    fbb_.AddElement<int32_t>(TensorArray::VT_DATA_TYPE, data_type, 0);
  }
  explicit TensorArrayBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArray> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArray>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArray> CreateTensorArray(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> element_shape = 0,
    int32_t data_type = 0) {
  TensorArrayBuilder builder_(_fbb);
  builder_.add_data_type(data_type);
  builder_.add_element_shape(element_shape);
  builder_.add_identical_element_shapes(identical_element_shapes);
  builder_.add_dynamic_size(dynamic_size);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorArray> CreateTensorArrayDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool dynamic_size = false,
    bool identical_element_shapes = false,
    const std::vector<int32_t> *element_shape = nullptr,
    int32_t data_type = 0) {
  auto element_shape__ = element_shape ? _fbb.CreateVector<int32_t>(*element_shape) : 0;
  return mindspore::schema::CreateTensorArray(
      _fbb,
      dynamic_size,
      identical_element_shapes,
      element_shape__,
      data_type);
}

struct TensorArrayRead FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayReadBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TensorArrayReadBuilder {
  typedef TensorArrayRead Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TensorArrayReadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArrayRead> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArrayRead>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArrayRead> CreateTensorArrayRead(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TensorArrayReadBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TensorArrayWrite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorArrayWriteBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TensorArrayWriteBuilder {
  typedef TensorArrayWrite Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TensorArrayWriteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorArrayWrite> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorArrayWrite>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorArrayWrite> CreateTensorArrayWrite(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TensorArrayWriteBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Affine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AffineBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONTEXT = 4,
    VT_OUTPUT_DIM = 6,
    VT_ACTIVATION_TYPE = 8,
    VT_TRANSPOSE_A = 10,
    VT_TRANSPOSE_B = 12
  };
  const flatbuffers::Vector<int64_t> *context() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_CONTEXT);
  }
  int64_t output_dim() const {
    return GetField<int64_t>(VT_OUTPUT_DIM, 0);
  }
  mindspore::schema::ActivationType activation_type() const {
    return static_cast<mindspore::schema::ActivationType>(GetField<int8_t>(VT_ACTIVATION_TYPE, 0));
  }
  bool transpose_a() const {
    return GetField<uint8_t>(VT_TRANSPOSE_A, 0) != 0;
  }
  bool transpose_b() const {
    return GetField<uint8_t>(VT_TRANSPOSE_B, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONTEXT) &&
           verifier.VerifyVector(context()) &&
           VerifyField<int64_t>(verifier, VT_OUTPUT_DIM) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATION_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_A) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSE_B) &&
           verifier.EndTable();
  }
};

struct AffineBuilder {
  typedef Affine Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_context(flatbuffers::Offset<flatbuffers::Vector<int64_t>> context) {
    fbb_.AddOffset(Affine::VT_CONTEXT, context);
  }
  void add_output_dim(int64_t output_dim) {
    fbb_.AddElement<int64_t>(Affine::VT_OUTPUT_DIM, output_dim, 0);
  }
  void add_activation_type(mindspore::schema::ActivationType activation_type) {
    fbb_.AddElement<int8_t>(Affine::VT_ACTIVATION_TYPE, static_cast<int8_t>(activation_type), 0);
  }
  void add_transpose_a(bool transpose_a) {
    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_A, static_cast<uint8_t>(transpose_a), 0);
  }
  void add_transpose_b(bool transpose_b) {
    fbb_.AddElement<uint8_t>(Affine::VT_TRANSPOSE_B, static_cast<uint8_t>(transpose_b), 0);
  }
  explicit AffineBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Affine> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Affine>(end);
    return o;
  }
};

inline flatbuffers::Offset<Affine> CreateAffine(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> context = 0,
    int64_t output_dim = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    bool transpose_a = false,
    bool transpose_b = false) {
  AffineBuilder builder_(_fbb);
  builder_.add_output_dim(output_dim);
  builder_.add_context(context);
  builder_.add_transpose_b(transpose_b);
  builder_.add_transpose_a(transpose_a);
  builder_.add_activation_type(activation_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Affine> CreateAffineDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *context = nullptr,
    int64_t output_dim = 0,
    mindspore::schema::ActivationType activation_type = mindspore::schema::ActivationType_NO_ACTIVATION,
    bool transpose_a = false,
    bool transpose_b = false) {
  auto context__ = context ? _fbb.CreateVector<int64_t>(*context) : 0;
  return mindspore::schema::CreateAffine(
      _fbb,
      context__,
      output_dim,
      activation_type,
      transpose_a,
      transpose_b);
}

struct ScatterNdUpdate FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ScatterNdUpdateBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterNdUpdateBuilder {
  typedef ScatterNdUpdate Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNdUpdateBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ScatterNdUpdate> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterNdUpdate>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterNdUpdate> CreateScatterNdUpdate(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNdUpdateBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AllGather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AllGatherBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUP = 4,
    VT_RANK_SIZE = 6
  };
  const flatbuffers::String *group() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUP);
  }
  int32_t rank_size() const {
    return GetField<int32_t>(VT_RANK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUP) &&
           verifier.VerifyString(group()) &&
           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
           verifier.EndTable();
  }
};

struct AllGatherBuilder {
  typedef AllGather Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
    fbb_.AddOffset(AllGather::VT_GROUP, group);
  }
  void add_rank_size(int32_t rank_size) {
    fbb_.AddElement<int32_t>(AllGather::VT_RANK_SIZE, rank_size, 0);
  }
  explicit AllGatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<AllGather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AllGather>(end);
    return o;
  }
};

inline flatbuffers::Offset<AllGather> CreateAllGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> group = 0,
    int32_t rank_size = 0) {
  AllGatherBuilder builder_(_fbb);
  builder_.add_rank_size(rank_size);
  builder_.add_group(group);
  return builder_.Finish();
}

inline flatbuffers::Offset<AllGather> CreateAllGatherDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *group = nullptr,
    int32_t rank_size = 0) {
  auto group__ = group ? _fbb.CreateString(group) : 0;
  return mindspore::schema::CreateAllGather(
      _fbb,
      group__,
      rank_size);
}

struct ReduceScatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReduceScatterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GROUP = 4,
    VT_MODE = 6,
    VT_RANK_SIZE = 8
  };
  const flatbuffers::String *group() const {
    return GetPointer<const flatbuffers::String *>(VT_GROUP);
  }
  mindspore::schema::ReduceMode mode() const {
    return static_cast<mindspore::schema::ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  int32_t rank_size() const {
    return GetField<int32_t>(VT_RANK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GROUP) &&
           verifier.VerifyString(group()) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<int32_t>(verifier, VT_RANK_SIZE) &&
           verifier.EndTable();
  }
};

struct ReduceScatterBuilder {
  typedef ReduceScatter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_group(flatbuffers::Offset<flatbuffers::String> group) {
    fbb_.AddOffset(ReduceScatter::VT_GROUP, group);
  }
  void add_mode(mindspore::schema::ReduceMode mode) {
    fbb_.AddElement<int8_t>(ReduceScatter::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_rank_size(int32_t rank_size) {
    fbb_.AddElement<int32_t>(ReduceScatter::VT_RANK_SIZE, rank_size, 0);
  }
  explicit ReduceScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ReduceScatter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReduceScatter>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReduceScatter> CreateReduceScatter(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> group = 0,
    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
    int32_t rank_size = 0) {
  ReduceScatterBuilder builder_(_fbb);
  builder_.add_rank_size(rank_size);
  builder_.add_group(group);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReduceScatter> CreateReduceScatterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *group = nullptr,
    mindspore::schema::ReduceMode mode = mindspore::schema::ReduceMode_ReduceMean,
    int32_t rank_size = 0) {
  auto group__ = group ? _fbb.CreateString(group) : 0;
  return mindspore::schema::CreateReduceScatter(
      _fbb,
      group__,
      mode,
      rank_size);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const mindspore::schema::Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const mindspore::schema::Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const mindspore::schema::Adam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AdderFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AdderFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const mindspore::schema::AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const mindspore::schema::All *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const mindspore::schema::ApplyMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMaxFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMaxFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMinFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ArgMinFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assert *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const mindspore::schema::Assign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::AssignAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const mindspore::schema::AudioSpectrogram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AvgPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AvgPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AvgPoolGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchNormGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const mindspore::schema::BatchToSpaceND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BinaryCrossEntropyGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAddGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::BiasAddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const mindspore::schema::BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const mindspore::schema::Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const mindspore::schema::Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const mindspore::schema::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Attention: {
      auto ptr = reinterpret_cast<const mindspore::schema::Attention *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DBackpropFilterFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropFilterFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DBackpropInputFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DBackpropInputFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2DFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2dTransposeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::Conv2dTransposeFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const mindspore::schema::Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const mindspore::schema::ConstantOfShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const mindspore::schema::Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomExtractFeatures *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomNormalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const mindspore::schema::CustomPredict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const mindspore::schema::DeConv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const mindspore::schema::Depend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const mindspore::schema::DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const mindspore::schema::Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::DropoutGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const mindspore::schema::Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const mindspore::schema::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::EmbeddingLookupFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const mindspore::schema::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVarsPerChannel: {
      auto ptr = reinterpret_cast<const mindspore::schema::FakeQuantWithMinMaxVarsPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const mindspore::schema::FftImag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const mindspore::schema::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::FlattenGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const mindspore::schema::Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const mindspore::schema::FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const mindspore::schema::Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const mindspore::schema::FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const mindspore::schema::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const mindspore::schema::Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const mindspore::schema::HashtableLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const mindspore::schema::InstanceNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNormFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyRelu: {
      auto ptr = reinterpret_cast<const mindspore::schema::LeakyRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const mindspore::schema::Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const mindspore::schema::Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const mindspore::schema::LpNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LRN: {
      auto ptr = reinterpret_cast<const mindspore::schema::LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const mindspore::schema::LshProjection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LSTM: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTM *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2NormalizeFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::L2NormalizeFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MatMulFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaximumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaxPoolFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaxPoolGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MaxPoolGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SwitchLayer: {
      auto ptr = reinterpret_cast<const mindspore::schema::SwitchLayer *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mfcc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const mindspore::schema::Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MinimumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const mindspore::schema::Mod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const mindspore::schema::Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::NegGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const mindspore::schema::NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonMaxSuppression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const mindspore::schema::OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::OnesLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PadFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PadFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PartialFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PartialFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PowFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const mindspore::schema::PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PReLUFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::PReLUFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const mindspore::schema::QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const mindspore::schema::Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reciprocal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const mindspore::schema::RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReduceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReduceFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const mindspore::schema::Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseV2: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReverseV2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rfft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const mindspore::schema::ROIPooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const mindspore::schema::Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScaleFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScaleFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterNd: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SGD: {
      auto ptr = reinterpret_cast<const mindspore::schema::SGD *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const mindspore::schema::Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const mindspore::schema::SkipGram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SliceFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SliceFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1Loss *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SmoothL1LossGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Softmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SoftmaxCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const mindspore::schema::SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseSoftmaxCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const mindspore::schema::SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const mindspore::schema::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const mindspore::schema::Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const mindspore::schema::Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const mindspore::schema::SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const mindspore::schema::Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListFromTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListReserve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListSetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorListStack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TileFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TileFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopKFusion: {
      auto ptr = reinterpret_cast<const mindspore::schema::TopKFusion *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const mindspore::schema::Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::UnsortedSegmentSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const mindspore::schema::Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LSTMGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LSTMGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const mindspore::schema::Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const mindspore::schema::ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const mindspore::schema::Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterNdUpdate: {
      auto ptr = reinterpret_cast<const mindspore::schema::ScatterNdUpdate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GRU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GRU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonZero: {
      auto ptr = reinterpret_cast<const mindspore::schema::NonZero *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InvertPermutation: {
      auto ptr = reinterpret_cast<const mindspore::schema::InvertPermutation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Size: {
      auto ptr = reinterpret_cast<const mindspore::schema::Size *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RandomStandardNormal: {
      auto ptr = reinterpret_cast<const mindspore::schema::RandomStandardNormal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CropAndResize: {
      auto ptr = reinterpret_cast<const mindspore::schema::CropAndResize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Erf: {
      auto ptr = reinterpret_cast<const mindspore::schema::Erf *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSliceGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::StridedSliceGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_IsFinite: {
      auto ptr = reinterpret_cast<const mindspore::schema::IsFinite *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LinSpace: {
      auto ptr = reinterpret_cast<const mindspore::schema::LinSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UniformReal: {
      auto ptr = reinterpret_cast<const mindspore::schema::UniformReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AbsGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::AbsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RsqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::RsqrtGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SqrtGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::SqrtGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNormGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::LayerNormGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ResizeGrad: {
      auto ptr = reinterpret_cast<const mindspore::schema::ResizeGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Splice: {
      auto ptr = reinterpret_cast<const mindspore::schema::Splice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogSoftmax: {
      auto ptr = reinterpret_cast<const mindspore::schema::LogSoftmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Call: {
      auto ptr = reinterpret_cast<const mindspore::schema::Call *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const mindspore::schema::Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CumSum: {
      auto ptr = reinterpret_cast<const mindspore::schema::CumSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SplitWithOverlap: {
      auto ptr = reinterpret_cast<const mindspore::schema::SplitWithOverlap *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GenOP: {
      auto ptr = reinterpret_cast<const mindspore::schema::GenOP *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RaggedRange: {
      auto ptr = reinterpret_cast<const mindspore::schema::RaggedRange *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GLU: {
      auto ptr = reinterpret_cast<const mindspore::schema::GLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArray: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArray *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArrayRead: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayRead *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorArrayWrite: {
      auto ptr = reinterpret_cast<const mindspore::schema::TensorArrayWrite *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Affine: {
      auto ptr = reinterpret_cast<const mindspore::schema::Affine *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AllGather: {
      auto ptr = reinterpret_cast<const mindspore::schema::AllGather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReduceScatter: {
      auto ptr = reinterpret_cast<const mindspore::schema::ReduceScatter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
