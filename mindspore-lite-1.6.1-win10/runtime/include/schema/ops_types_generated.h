// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace mindspore {
namespace schema {

struct Vec;
struct VecBuilder;

struct Vec2D;
struct Vec2DBuilder;

struct Attribute;
struct AttributeBuilder;

enum ResizeMethod : int8_t {
  ResizeMethod_UNKNOWN = -1,
  ResizeMethod_LINEAR = 0,
  ResizeMethod_NEAREST = 1,
  ResizeMethod_CUBIC = 2,
  ResizeMethod_MIN = ResizeMethod_UNKNOWN,
  ResizeMethod_MAX = ResizeMethod_CUBIC
};

inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
  static const ResizeMethod values[] = {
    ResizeMethod_UNKNOWN,
    ResizeMethod_LINEAR,
    ResizeMethod_NEAREST,
    ResizeMethod_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesResizeMethod() {
  static const char * const names[5] = {
    "UNKNOWN",
    "LINEAR",
    "NEAREST",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMethod(ResizeMethod e) {
  if (flatbuffers::IsOutRange(e, ResizeMethod_UNKNOWN, ResizeMethod_CUBIC)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOWN);
  return EnumNamesResizeMethod()[index];
}

enum CoordinateTransformMode : int8_t {
  CoordinateTransformMode_ASYMMETRIC = 0,
  CoordinateTransformMode_ALIGN_CORNERS = 1,
  CoordinateTransformMode_HALF_PIXEL = 2,
  CoordinateTransformMode_MIN = CoordinateTransformMode_ASYMMETRIC,
  CoordinateTransformMode_MAX = CoordinateTransformMode_HALF_PIXEL
};

inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[3] {
  static const CoordinateTransformMode values[] = {
    CoordinateTransformMode_ASYMMETRIC,
    CoordinateTransformMode_ALIGN_CORNERS,
    CoordinateTransformMode_HALF_PIXEL
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformMode() {
  static const char * const names[4] = {
    "ASYMMETRIC",
    "ALIGN_CORNERS",
    "HALF_PIXEL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
  if (flatbuffers::IsOutRange(e, CoordinateTransformMode_ASYMMETRIC, CoordinateTransformMode_HALF_PIXEL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformMode()[index];
}

enum NearestMode : int8_t {
  NearestMode_NORMAL = 0,
  NearestMode_ROUND_HALF_DOWN = 1,
  NearestMode_ROUND_HALF_UP = 2,
  NearestMode_FLOOR = 3,
  NearestMode_CEIL = 4,
  NearestMode_MIN = NearestMode_NORMAL,
  NearestMode_MAX = NearestMode_CEIL
};

inline const NearestMode (&EnumValuesNearestMode())[5] {
  static const NearestMode values[] = {
    NearestMode_NORMAL,
    NearestMode_ROUND_HALF_DOWN,
    NearestMode_ROUND_HALF_UP,
    NearestMode_FLOOR,
    NearestMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesNearestMode() {
  static const char * const names[6] = {
    "NORMAL",
    "ROUND_HALF_DOWN",
    "ROUND_HALF_UP",
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNearestMode(NearestMode e) {
  if (flatbuffers::IsOutRange(e, NearestMode_NORMAL, NearestMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNearestMode()[index];
}

enum Format : int32_t {
  Format_NCHW = 0,
  Format_NHWC = 1,
  Format_NHWC4 = 2,
  Format_HWKC = 3,
  Format_HWCK = 4,
  Format_KCHW = 5,
  Format_CKHW = 6,
  Format_KHWC = 7,
  Format_CHWK = 8,
  Format_HW = 9,
  Format_HW4 = 10,
  Format_NC = 11,
  Format_NC4 = 12,
  Format_NC4HW4 = 13,
  Format_NUM_OF_FORMAT = 14,
  Format_NCDHW = 15,
  Format_NWC = 16,
  Format_NCW = 17,
  Format_MIN = Format_NCHW,
  Format_MAX = Format_NCW
};

inline const Format (&EnumValuesFormat())[18] {
  static const Format values[] = {
    Format_NCHW,
    Format_NHWC,
    Format_NHWC4,
    Format_HWKC,
    Format_HWCK,
    Format_KCHW,
    Format_CKHW,
    Format_KHWC,
    Format_CHWK,
    Format_HW,
    Format_HW4,
    Format_NC,
    Format_NC4,
    Format_NC4HW4,
    Format_NUM_OF_FORMAT,
    Format_NCDHW,
    Format_NWC,
    Format_NCW
  };
  return values;
}

inline const char * const *EnumNamesFormat() {
  static const char * const names[19] = {
    "NCHW",
    "NHWC",
    "NHWC4",
    "HWKC",
    "HWCK",
    "KCHW",
    "CKHW",
    "KHWC",
    "CHWK",
    "HW",
    "HW4",
    "NC",
    "NC4",
    "NC4HW4",
    "NUM_OF_FORMAT",
    "NCDHW",
    "NWC",
    "NCW",
    nullptr
  };
  return names;
}

inline const char *EnumNameFormat(Format e) {
  if (flatbuffers::IsOutRange(e, Format_NCHW, Format_NCW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesFormat()[index];
}

enum ActivationType : int8_t {
  ActivationType_NO_ACTIVATION = 0,
  ActivationType_RELU = 1,
  ActivationType_SIGMOID = 2,
  ActivationType_RELU6 = 3,
  ActivationType_ELU = 4,
  ActivationType_LEAKY_RELU = 5,
  ActivationType_ABS = 6,
  ActivationType_RELU1 = 7,
  ActivationType_SOFTSIGN = 8,
  ActivationType_SOFTPLUS = 9,
  ActivationType_TANH = 10,
  ActivationType_SELU = 11,
  ActivationType_HSWISH = 12,
  ActivationType_HSIGMOID = 13,
  ActivationType_THRESHOLDRELU = 14,
  ActivationType_LINEAR = 15,
  ActivationType_HARD_TANH = 16,
  ActivationType_SIGN = 17,
  ActivationType_SWISH = 18,
  ActivationType_GELU = 19,
  ActivationType_UNKNOWN = 20,
  ActivationType_MIN = ActivationType_NO_ACTIVATION,
  ActivationType_MAX = ActivationType_UNKNOWN
};

inline const ActivationType (&EnumValuesActivationType())[21] {
  static const ActivationType values[] = {
    ActivationType_NO_ACTIVATION,
    ActivationType_RELU,
    ActivationType_SIGMOID,
    ActivationType_RELU6,
    ActivationType_ELU,
    ActivationType_LEAKY_RELU,
    ActivationType_ABS,
    ActivationType_RELU1,
    ActivationType_SOFTSIGN,
    ActivationType_SOFTPLUS,
    ActivationType_TANH,
    ActivationType_SELU,
    ActivationType_HSWISH,
    ActivationType_HSIGMOID,
    ActivationType_THRESHOLDRELU,
    ActivationType_LINEAR,
    ActivationType_HARD_TANH,
    ActivationType_SIGN,
    ActivationType_SWISH,
    ActivationType_GELU,
    ActivationType_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[22] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "HARD_TANH",
    "SIGN",
    "SWISH",
    "GELU",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (flatbuffers::IsOutRange(e, ActivationType_NO_ACTIVATION, ActivationType_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum ReduceMode : int8_t {
  ReduceMode_ReduceMean = 0,
  ReduceMode_ReduceMax = 1,
  ReduceMode_ReduceMin = 2,
  ReduceMode_ReduceProd = 3,
  ReduceMode_ReduceSum = 4,
  ReduceMode_ReduceSumSquare = 5,
  ReduceMode_ReduceASum = 6,
  ReduceMode_ReduceAll = 7,
  ReduceMode_MIN = ReduceMode_ReduceMean,
  ReduceMode_MAX = ReduceMode_ReduceAll
};

inline const ReduceMode (&EnumValuesReduceMode())[8] {
  static const ReduceMode values[] = {
    ReduceMode_ReduceMean,
    ReduceMode_ReduceMax,
    ReduceMode_ReduceMin,
    ReduceMode_ReduceProd,
    ReduceMode_ReduceSum,
    ReduceMode_ReduceSumSquare,
    ReduceMode_ReduceASum,
    ReduceMode_ReduceAll
  };
  return values;
}

inline const char * const *EnumNamesReduceMode() {
  static const char * const names[9] = {
    "ReduceMean",
    "ReduceMax",
    "ReduceMin",
    "ReduceProd",
    "ReduceSum",
    "ReduceSumSquare",
    "ReduceASum",
    "ReduceAll",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceMode(ReduceMode e) {
  if (flatbuffers::IsOutRange(e, ReduceMode_ReduceMean, ReduceMode_ReduceAll)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceMode()[index];
}

enum PoolMode : int8_t {
  PoolMode_MAX_POOLING = 0,
  PoolMode_MEAN_POOLING = 1,
  PoolMode_MIN = PoolMode_MAX_POOLING,
  PoolMode_MAX = PoolMode_MEAN_POOLING
};

inline const PoolMode (&EnumValuesPoolMode())[2] {
  static const PoolMode values[] = {
    PoolMode_MAX_POOLING,
    PoolMode_MEAN_POOLING
  };
  return values;
}

inline const char * const *EnumNamesPoolMode() {
  static const char * const names[3] = {
    "MAX_POOLING",
    "MEAN_POOLING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolMode(PoolMode e) {
  if (flatbuffers::IsOutRange(e, PoolMode_MAX_POOLING, PoolMode_MEAN_POOLING)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolMode()[index];
}

enum EltwiseMode : int8_t {
  EltwiseMode_PROD = 0,
  EltwiseMode_SUM = 1,
  EltwiseMode_MAXIMUM = 2,
  EltwiseMode_UNKNOWN = 3,
  EltwiseMode_MIN = EltwiseMode_PROD,
  EltwiseMode_MAX = EltwiseMode_UNKNOWN
};

inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
  static const EltwiseMode values[] = {
    EltwiseMode_PROD,
    EltwiseMode_SUM,
    EltwiseMode_MAXIMUM,
    EltwiseMode_UNKNOWN
  };
  return values;
}

inline const char * const *EnumNamesEltwiseMode() {
  static const char * const names[5] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "UNKNOWN",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseMode(EltwiseMode e) {
  if (flatbuffers::IsOutRange(e, EltwiseMode_PROD, EltwiseMode_UNKNOWN)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseMode()[index];
}

enum PadMode : int8_t {
  PadMode_PAD = 0,
  PadMode_SAME = 1,
  PadMode_VALID = 2,
  PadMode_MIN = PadMode_PAD,
  PadMode_MAX = PadMode_VALID
};

inline const PadMode (&EnumValuesPadMode())[3] {
  static const PadMode values[] = {
    PadMode_PAD,
    PadMode_SAME,
    PadMode_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[4] = {
    "PAD",
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (flatbuffers::IsOutRange(e, PadMode_PAD, PadMode_VALID)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum RoundMode : int8_t {
  RoundMode_FLOOR = 0,
  RoundMode_CEIL = 1,
  RoundMode_MIN = RoundMode_FLOOR,
  RoundMode_MAX = RoundMode_CEIL
};

inline const RoundMode (&EnumValuesRoundMode())[2] {
  static const RoundMode values[] = {
    RoundMode_FLOOR,
    RoundMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesRoundMode() {
  static const char * const names[3] = {
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoundMode(RoundMode e) {
  if (flatbuffers::IsOutRange(e, RoundMode_FLOOR, RoundMode_CEIL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoundMode()[index];
}

enum PaddingMode : int8_t {
  PaddingMode_CONSTANT = 0,
  PaddingMode_REFLECT = 1,
  PaddingMode_SYMMETRIC = 2,
  PaddingMode_MODE_RESERVED = 3,
  PaddingMode_MIN = PaddingMode_CONSTANT,
  PaddingMode_MAX = PaddingMode_MODE_RESERVED
};

inline const PaddingMode (&EnumValuesPaddingMode())[4] {
  static const PaddingMode values[] = {
    PaddingMode_CONSTANT,
    PaddingMode_REFLECT,
    PaddingMode_SYMMETRIC,
    PaddingMode_MODE_RESERVED
  };
  return values;
}

inline const char * const *EnumNamesPaddingMode() {
  static const char * const names[5] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "MODE_RESERVED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingMode(PaddingMode e) {
  if (flatbuffers::IsOutRange(e, PaddingMode_CONSTANT, PaddingMode_MODE_RESERVED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingMode()[index];
}

enum LshProjectionType : int8_t {
  LshProjectionType_UNKNOWN = 0,
  LshProjectionType_SPARSE = 1,
  LshProjectionType_DENSE = 2,
  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
  LshProjectionType_MAX = LshProjectionType_DENSE
};

inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
  static const LshProjectionType values[] = {
    LshProjectionType_UNKNOWN,
    LshProjectionType_SPARSE,
    LshProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLshProjectionType() {
  static const char * const names[4] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLshProjectionType(LshProjectionType e) {
  if (flatbuffers::IsOutRange(e, LshProjectionType_UNKNOWN, LshProjectionType_DENSE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLshProjectionType()[index];
}

enum Reduction : int8_t {
  Reduction_REDUCTION_SUM = 0,
  Reduction_MEAN = 1,
  Reduction_NONE = 2,
  Reduction_MIN = Reduction_REDUCTION_SUM,
  Reduction_MAX = Reduction_NONE
};

inline const Reduction (&EnumValuesReduction())[3] {
  static const Reduction values[] = {
    Reduction_REDUCTION_SUM,
    Reduction_MEAN,
    Reduction_NONE
  };
  return values;
}

inline const char * const *EnumNamesReduction() {
  static const char * const names[4] = {
    "REDUCTION_SUM",
    "MEAN",
    "NONE",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduction(Reduction e) {
  if (flatbuffers::IsOutRange(e, Reduction_REDUCTION_SUM, Reduction_NONE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduction()[index];
}

struct Vec FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef VecBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<int64_t> *data() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct VecBuilder {
  typedef Vec Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<int64_t>> data) {
    fbb_.AddOffset(Vec::VT_DATA, data);
  }
  explicit VecBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vec> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec> CreateVec(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> data = 0) {
  VecBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vec> CreateVecDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<int64_t>(*data) : 0;
  return mindspore::schema::CreateVec(
      _fbb,
      data__);
}

struct Vec2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef Vec2DBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *data() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.VerifyVectorOfTables(data()) &&
           verifier.EndTable();
  }
};

struct Vec2DBuilder {
  typedef Vec2D Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data) {
    fbb_.AddOffset(Vec2D::VT_DATA, data);
  }
  explicit Vec2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Vec2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Vec2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Vec2D> CreateVec2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<mindspore::schema::Vec>>> data = 0) {
  Vec2DBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Vec2D> CreateVec2DDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<mindspore::schema::Vec>> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<flatbuffers::Offset<mindspore::schema::Vec>>(*data) : 0;
  return mindspore::schema::CreateVec2D(
      _fbb,
      data__);
}

struct Attribute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef AttributeBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DATA = 6
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct AttributeBuilder {
  typedef Attribute Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Attribute::VT_NAME, name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Attribute::VT_DATA, data);
  }
  explicit AttributeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Attribute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Attribute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Attribute> CreateAttribute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  AttributeBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<Attribute> CreateAttributeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint8_t> *data = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return mindspore::schema::CreateAttribute(
      _fbb,
      name__,
      data__);
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPSTYPES_MINDSPORE_SCHEMA_H_
